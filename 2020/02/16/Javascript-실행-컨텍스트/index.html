
<!DOCTYPE html>
<html lang="ko">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="공부방">
    <title>[Javascript] 실행 컨텍스트 - 공부방</title>
    <meta name="author" content="dajyu">
    
        <meta name="keywords" content="React,Typescript,HTML,CSS,Frontend,">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"dajyu","sameAs":["https://github.com/cok2exe","http://stackoverflow.com/cok2exe"],"image":"cat.jpeg"},"articleBody":"실행 컨텍스트는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체로, 자바스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 개념이다. 자바스크립트는 어떤 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어올리고(호이스팅), 외부 환경 정보를 구성하고, this 값을 설정하는 등의 동작을 수행하는데, 이로 인해 다른 언어에서는 발견할 수 없는 특이한 현상들이 발생한다.\n\n\n1. 실행 컨텍스트란?\n스택: 출입구가 하나뿐인 깊은 우물 같은 데이터 구조. 비어있는 스택에 순서대로 데이터 a,b,c,d를 저장했다면, 꺼낼 때는 반대로 d,c,b,a의 순서로 꺼낼 수 밖에 없다. 100개만 저장할 수 있는 우물에 100개가 넘는 데이터를 넣으려고 하면 넘칠 수밖에 없음 =&gt; 오버플로우!\n큐: 양쪽이 모두 열려있는 파이프를 떠올리면 됨. 종류에 따라 양쪽 모두 입력과 출력이 가능한 큐도 있으나 보통은 한쪽은 입력만, 다른 한쪽은 출력만 담당하는 구조를 말한다. a,b,c,d를 넣으면 a,b,c,d 순서대로 꺼낼 수 있음.\n\n동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보들을 모아 실행 컨텍스트를 구성하고, 이를 콜 스택에 쌓아올렸다가, 가장 위에 쌓여있는 컨텍스트와 관련 있는 코드들을 실행하는 식으로 전체 코드의 환경과 순서를 보장한다. 여기서 ‘동일한 환경’, 즉 하나의 실행 컨텍스트를 구성할 수 있는 방법으로 전역공간, eval() 함수, 함수 등이 있다.\n우리가 흔히 실행 컨텍스트를 구성하는 방법은 함수를 실행하는 것이다.\n123456789101112// ------------------------- (1)var a = 1;function outer() &#123;  function inner() &#123;    console.log(a); // undefined    var a = 3;  &#125;  inner(); // -------------- (2)  console.log(a); // 1&#125;outer(); // ---------------- (3)console.log(a); // 1\n\n처음 자바스크립트 코드를 실행하는 순간(1) 전역 컨텍스트가 콜 스택에 담긴다. 전역 컨텍스트라는 개념은 일반적인 실행 컨텍스트와 특별히 다를 것이 없다. 최상단의 공간은 코드 내부에서 별도의 실행 명령이 없어도 브라우저에서 자동으로 실행하므로 자바스크립트 파일이 열리는 순간 전역 컨텍스트가 활성화된다고 이해하면 된다.\n전역 컨텍스트 외에 다른 덩어리가 없으므로 전역 컨텍스트와 관련된 코드들을 순차로 진행하다가 (3)에서 outer 함수를 호출하면 자바스크립트 엔진은 outer에 대한 환경 정보를 수집해서 outer 실행 컨텍스트를 생성한 후 콜 스택에 담는다. 콜 스택의 맨 위에 outer 실행 컨텍스트가 놓인 상태가 됐으므로 전역 컨텍스트와 관련된 코드의 실행을 일시중단하고 대신 outer 실행 컨텍스트와 관련된 코드, 즉 outer 함수 내부의 코드들을 순차로 실행한다.\n다시 (2)에서 inner 함수의 신행 컨텍스트가 콜 스택의 가장 위에 담기면 outer 콘텍스트와 관련된 코드의 실행을 중단하고 inner 함수 내부의 코드를 순서대로 진행할 것이다.\n스택 구조를 잘 생각해보면 한 실행 컨텍스트가 콜 스택의 맨 위에 쌓이는 순간이 곧 현재 실행할 코드에 관여하게 되는 시점임을 알 수 있다. 기존의 컨텍스트는 새로 쌓인 컨텍스트보다 아래에 위치할 수밖에 없기 때문이다. 이렇게 어떤 실행 컨텍스트가 활성화될 때 자바스크립트 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는 데 필요한 환경 정보들을 수집해서 실행 컨텍스트 객체에 저장한다. 이 객체는 자바스크립트 엔진이 활용할 목적으로 생성할 뿐 개발자가 코드를 통해 확인할 수는 없다. 여기에 담기는 정보들을 다음과 같다.\n\nVariableEnvironment: 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보, 선언 시점의 LexicalEnvironment의 스냅샷으로, 변경사항은 반영되지 않음.\nLexicalEnvironment: 처음에는 VariableEnvironment와 같지만 변경 사항이 실시간으로 반영됨\nThisBinding: this 식별자가 바라봐야 할 대상 객체\n\n\n2. VariableEnvironmentVariableEnvironment에 담기는 내용은 LexicalEnvironment와 같지만 최초 실행 시의 스냅샷을 유지한다는 점이 다르다. 실행 컨텍스트를 생성할 때 VariableEnvironment에 정보를 먼저 담은 다음, 이를 그대로 복사해서 LexicalEnvironment를 만들고, 이후에는 LexicalEnvironment를 주로 활용하게 된다.\nVariableEnvironment와 LexicalEnvironment의 내부는 environmentRecord와 outer-EnvironmentReference로 구성돼 있다. 초기화 과정 중에는 사실상 완전히 동일하고 이후 코드 진행에 따라 서로 달라지게 됨.\n\n3. LexicalEnvironment\n현재 컨텍스트의 내부에는 a, b, c와 같은 식별자들이 있고 그 외부 정보는 D를 참조하도록 구성돼 있다.\n컨텍스트를 구성하는 환경 정보들을 사전에서 접하는 느낌으로 모아놓은 것.\n\n3-1. environmentRecord와 호이스팅environmentRecord에는 현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장된다. 컨텍스트를 구성하는 함수에 지정된 매개변수 식별자, 선언된 함수가 있을 경우 그 함수 자체, var로 선언된 변수의 식별자 등이 식별자에 해당된다. 컨텍스트 내부 전체를 처음부터 끝까지 훑어나가며 순서대로 수집한다.\n\n코드가 실행되기 전임에도 불구하고 자바스크립트 엔진은 이미 해당 환경에 속한 코드의 변수명들을 모두 알고 있게 되는 셈이다.\n여기서 등장한 개념이 바로 ‘호이스팅’ 이다.\n\n호이스팅 규칙\nenvironmentRecord에는 매개변수의 이름, 함수 선언, 변수명 등이 담긴다.\n[예제 2-2 매개변수와 변수에 대한 호이스팅(1) - 원본 코드]\n12345678function a (x) &#123;  // 수집 대상 1(매개 변수)  console.log(x); // (1)  var x;          // 수집 대상 2(변수 선언)  console.log(x); // (2)  var x = 2;      // 수집 대상 3(변수 선언)  console.log(x); // (3)&#125;a(1)\n\n우선 호이스팅이 되지 않았을 때 (1), (2), (3)에서 어떤 값들이 출력될지를 예상해 보자. (1)에는 1, (2)에는 undefined, (3)에는 2가 출력될 것이다.\n실제로는 어떤 결과가 나올까?\n예제 2-2처럼 인자들과 함께 함수를 호출한 경우의 동작을 살펴보면, arguments에 전달된 인자를 담는 것을 제외하면 예제 2-3처럼 코드 내부에서 변수를 선언한 것과 다른 점이 없다. 특히 LexicalEnvironment 입장에서는 완전히 같다. 그러니까 인자를 함수 내부의 다른 코드보다 먼저 선언 및 할당이 이뤄진 것으로 간주할 수 있다.\n[예제 2-3 매개변수와 변수에 대한 호이스팅(2) - 매개변수를 변수 선언/할당과 같다고 간주해서 변환한 상태]\n123456789function a () &#123;  var x = 1;      // 수집 대상 1(매개 변수)  console.log(x); // (1)  var x;          // 수집 대상 2(변수 선언)  console.log(x); // (2)  var x = 2;      // 수집 대상 3(변수 선언)  console.log(x); // (3)&#125;a()\n\n이 상태에서 변수 정보를 수집하는 과정, 즉 호이스팅을 처리해 보자. environmentRecord는 현재 실행될 컨텍스트의 대상 코드 내에 어떤 식별자들이 있는지에만 관심이 있고, 각 식별자에 어떤 값이 할당될 것인지는 관심이 없다. 따라서 변수를 호이스팅할 때 변수명만 끌어올리고 할당 과정은 원래 자리에 그대로 남겨둔다. 매개변수의 경우도 마찬가지이다. environmentRecord의 관심사에 맞춰 수집 대상 1,2,3을 순서대로 끌어올리고 나면 다음과 같은 형태로 바뀐다.\n[예제 2-4 매개변수와 변수에 대한 호이스팅(3) - 호이스팅을 마친 상태]\n123456789101112function a () &#123;  var x;          // 수집 대상 1의 변수 선언 부분  var x;          // 수집 대상 2의 변수 선언 부분  var x;          // 수집 대상 3의 변수 선언 부분  x = 1;      // 수집 대상 1의 할당 부분  console.log(x); // (1)  console.log(x); // (2)  var x = 2;      // 수집 대상 3의 할당 부분  console.log(x); // (3)&#125;a(1);\n\n함수 선언문과 함수 표현식\n모두 함수를 새롭게 정의할 때 쓰이는 방식이다. 그중 함수 선언문은 function 정의부만 존재하고 별도의 할당 명령이 없는 것을 의미하고, 반대로 함수 표현식은 정의한 function을 별도의 변수에 할당하는 것을 의미한다. 함수 선언문의 경우 반드시 함수명이 정의돼 있어야 하는 반면, 함수 표현식은 없어도 된다. 함수명을 정의한 함수 표현식을 ‘기명 함수 표현식’, 정의하지 않은 것을 ‘익명 함수 표현식’이라고 부르기도 하는데, 일반적으로 함수 표현식은 익명 함수 표현식을 말한다.\n12345678function a () &#123;&#125; // 함수 선언문. 함수명 a가 곧 변수명.var b = function () &#123;&#125; // (익명) 함수 표현식. 변수명 b가 곧 함수명.b();var c = function d () &#123;&#125; // 기명 함수 표현식. 변수명은 c. 함수명은 d.c();d(); // 에러\n\n\n기명 함수 표현식은 주의할 점이 하나 있다. 바로 외부에서는 함수명으로 함수를 호출할 수 없다는 점이다. 함수명은 오직 함수 내부에서만 접근할 수 있다.\n함수 내부에서 재귀함수를 호출하는 용도로 함수명을 쓸 수 있다.\n\n12345678910console.log(sum(1, 2));console.log(multiply(3, 4));function sum (a, b) &#123; // 함수 선언문 sum  return a + b;&#125;var multiply = function (a, b) &#123; // 함수 표현식 multiply  return a * b;&#125;\n\n실행 컨텍스트의 LexicalEnvironment는 두 가지 정보를 수집하는데, 여기서는 그중에서 environmentRecord의 정보 수집 과정에서 발생하는 호이스팅을 살펴보는 중이다.\n12345678910var sum = function sum (a, b) &#123; // 함수 선언문 전체를 호이스팅한다.  return a + b;&#125;;var multiply;                   // 변수는 선언부만 끌어올린다.console.log(sum(1, 2));console.log(multiply(3, 4));multiply = function (a, b) &#123;    // 변수의 할당부는 원래 자리에 남겨둔다.  return a * b;&#125;\n\n함수 선언문은 전체를 호이스팅한 반면 함수 표현식은 변수 선언부만 호이스팅했다. 함수도 하나의 값으로 취급할 수 있다는 것이 바로 이런 것이다. 함수를 다른 변수에 값으로써 ‘할당’한 것이 곧 함수 표현식이다. 여기서 함수 선언문과 함수 표현식의 극적인 차이가 발생한다.\nsum 함수는 선언 전에 호출해도 아무 문제 없이 실행된다. \n전역 컨텍스트가 활성화될 때 전역공간에 선언된 함수들이 모두 가장 위로 끌어올려진다. 동일한 변수명에 서로 다른 값을 할당할 경우 나중에 할당한 값이 먼저 할당한 값을 덮어씌운다. 따라서 코드를 실행하는 중에 실제로 호출되는 함수는 오직 마지막에 할당한 함수, 즉 맨 마지막에 선언된 함수 뿐이다.\n\n상대적으로 함수 표현식이 함수 선언문보다 안전하다.\n\n3-2. 스코프, 스코프 체인, outerEnvironmentReference스코프(scope)란 식벼자에 대한 유효범위이다. ES5까지의 자바스크립트는 특이하게도 전역공간을 제외하면 오직 함수에 의해서만 스코프가 생선된다. 이러한 ‘식별자의 유효범위’를 안에서부터 바깥으로 차례로 검색해나가는 것을 스코프 체인이라고 한다. 그리고 이를 가능케 하는 것이 바로 LexicalEnvironment의 두 번째 수집 자료인 outerEnvironmentReference이다.\n스코프 체인\nouterEnvironmentReference는 현재 호출된 함수가 선언될 당시의 LexicalEnvironment를 참조한다. ‘선언하다’라는 행위가 실제로 일어날 수 있는 시점이란 콜 스택 상에서 어떤 실행 컨텍스트가 활성화된 상태일 때뿐이다. 어떤 함수를 선언(정의)하는 행위 자체도 하나의 코드에 지나지 않으며, 모든 코드는 실행 컨텍스트가 활성화 상태일 때 실행되기 때문이다.\n예를 들어, A 함수 내부에 B 함수를 선언하고 다시 B 함수 내부에 C 함수를 선언한 경우, 함수 C의 outerEnvironmentReference는 함수 B의 LexicalEnvironment를 참조한다. 함수 B의 LexicalEnvironment에 있는 outerEnvironmentReference는 다시 함수 B가 선언되던 때(A)의 LexicalEnvironment를 참조한다. 이처럼 outerEnvironemntReference는 연결리스트 형태를 띈다. 선언 시점의 LexicalEnvironment를 계속 찾아 올라가면 마지막엔 전역 컨텍스트의 LexicalEnvironment가 있을 것이다. 또한 각 outerEnvironmentReference는 오직 자신이 선언된 시점의 LexicalEnvironment만 참조하고 있으므로 가장 가까운 요소부터 차례대로만 접근할 수 있고 다른 순서로 접근하는 것은 불가능할 것이다. 이런 구조적 특성 덕분에 여러 스코프에서 동일한 식별자를 선언한 경우에는 무조건 스코프 체인 상에서 가장 먼저 발견된 식별자에만 접근 가능하게 된다.\n1234567891011var a = 1;var outer = function () &#123;  var inner = function () &#123;    console.log(a);    var a = 3;  &#125;;  inner();  console.log(a);&#125;;outer();console.log(a);\n\n\n시작: 전역 컨텍스트 활성화. 전역 컨텍스트의 environmentRecord에 { a, outer } 식별자를 저장. 전역 컨텍스트는 선언 시점이 없으므로 전역 컨텍스트의 outerEnvironmentReference에는 아무것도 담기지 않음\n1번째, 2번째 줄: 전역 스코프에 있는 변수 a에 1을, outer에 함수 할당.\n10번째 줄: outer 함수를 호출. 이에 따라 전역 컨텍스트의 코드는 10번째 줄에서 임시중단, outer 실행 컨텍스트가 활성화되어 2번째 줄로 이동.\n2번째 줄: outer 실행 컨텍스트의 environmentRecord에 { inner } 식별자 저장. outerEnvironmentReference에는 outer 함수가 선언될 당시의 LexicalEnvironment가 담김. outer 함수는 전역 공간에서 선언됐으므로 전역 컨텍스트의 LexicalEnvironment 참조 복사. 이를 { GLOBAL, { a, outer } } 라고 표기. 첫 번째는 실행 컨텍스트의 이름, 두 번째는 environmentRecord 객체.\n3번째 줄: outer 스코프에 있는 변수 inner에 함수 할당.\n7번째 줄: inner 함수 호출. outer 실행 컨텍스트와 코드는 7번째 줄에서 임시중단. inner 실행 컨텍스트가 활성화되어 3번째 줄로 이동.\n3번째 줄: inner 실행 컨텍스트의 environmentRecord에 { a } 식별자 저장. outerEnvironmentReference에는 inner 함수가 선언될 당시의 LexicalEnvironment 가 담김. inner 함수는 outer 함수 내부에서 선언됐으므로 outer 함수의 LexicalEnvironment, 즉 { outer, { inner } }를 참조 복사함.\n4번째 줄: 식별자 a에 접근하고자 함. 현재 활성화 상태인 inner 컨텍스트의 environmentRecord에서 a 검색. a가 발견됐는데 아직 할당된 값이 없음. undefined 출력.\n5번째 줄: inner 스코프에 있는 변수 a에 3 할당.\n6번째 줄: inner 함수 실행 종료. inner 실행 컨텍스트가 콜 스택에서 제거됨. 바로 아래에 있는 outer 실행 컨텍스트가 다시 활성화되면서 중단했던 7번째 줄의 다음으로 이동.\n8번째 줄: 식별자 a에 접근하고자 함. 이때 자바스크립트 엔진은 활성화된 실행 컨텍스트의 LexicalEnvironment에 접근. 첫 요소의 environmentRecord에서 a가 있는지 찾아보고, 없으면 outerEnvironmentReference에 있는 environmentRecord로 넘어가는 식으로 계속해서 검색함. 예제에서는 전역 LexicalEnvironment에 a가 있으니 1 반환.\n9번째 줄: outer 함수 실행 종료. outer 실행 컨텍스트가 콜 스택에서 제거됨. 바로 아래에 있는 전역 컨텍스트가 다시 활성화 되면서 중단했던 10번째 줄의 다음 줄로 이동.\n11번재 줄: 식별자 a에 접근. 현재 활성화 상태인 전역 컨텍스트의 environmentRecord에서 a를 검색. 바로 a 찾음 (1 출력). 이로써 모든 코드의 실행이 완료됨. 전역 컨텍스트가 콜 스택에서 제거되고 종료됨.\n\n전역 공간에서는 전역 스코프에서 생성된 변수에만 접근할 수 있다. outer 함수 내부에서는 outer 및 전역 스코프에서 생성된 변수에 접근할 수 있지만 inner 스코프 내부에서 생성된 변수에는 접근하지 못한다. inner 함수 내부에서는 inner, outer, 전역 스코프 모두에 접근할 수 있다.\n한편 스코프 체인 상에 있는 변수라고 해서 무조건 접근 가능한 것은 아니다. 위 코드 상의 식별자 a는 전역 공간에서도 선언했고 inner 함수 내부에서도 선언했다. inner 함수 내부에서 a에 접근하려고 하면 무조건 스코프 체인 상의 첫 번째 인자, 즉 inner 스코프의 LexicalEnvironment부터 검색할 수밖에 없다. inner 스코프의 LexicalEnvironment에 a 식별자가 존재하므로 스코프 체인 검색을 더 진행하지 않고 즉시 inner LexicalEnvironment 상의 a를 반환한다. 즉, inenr 함수 내부에서 a 변수를 선언했기 때문에 전역 공간에서 선언한 동일한 이름의 a 변수에는 접근할 수 없는 셈이다. 이를 변수 은닉화 라고 한다.\n전역변수와 지역변수\n전역변수는 전역 스코프에서 선언한 a와 outer 이다. 지역 변수는 outer 함수 내부에서 선언한 inner와 inner 함수 내부에서 선언한 a 이다. 즉 전역 공간에서 선언한 변수는 전역변수이고, 함수 내부에서 선언한 변수는 무조건 지역변수이다.\n\n코드의 안정성을 위해 가급적 전역변수 사용을 최소화하고자 노력하는 것이 좋다.\n\n\n4. this실행 컨텍스트의 thisBinding에는 this로 지정된 객체가 저장된다. 실행 컨텍스트는 활성화 당시에 this가 지정되지 않은 경우 this에는 전역 객체가 저장된다. 그밖에는 함수를 호출하는 방법에 따라 this에 저장되는 대상이 다르다.\n\n5. 정리\n실행 컨텍스트는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체이다.\n\n🔥🔥🔥핵심 키워드🔥🔥🔥#실행 컨텍스트, #LexicalEnvironment, #environmentRecord, #outerEnvironmentReference, #스코프, #전역변수, #지역변수, #this\n실행 컨텍스트 객체는 활성화되는 시점에 VariableEnvironment, LexicalEnvironment, thisBinding 세 가지 정보를 수집한다.\n실행 컨텍스트를 생성할 때는 VariableEnvironment와 LexicalEnvironment가 동일한 내용으로 구성되지만, LexicalEnvironment는 함수 실행 도중에 변경되는 사항이 즉시 반영되는 반면 VariableEnvironment는 초기 상태를 유지한다.\nVariableEnvironment와 LexicalEnvironment은 아래 두가지로 구성돼 있음.\n\nenvironmentRecord: 매개변수명, 변수의 식별자, 선언한 함수의 함수명 등을 수집\nouterEnvironmentReference: 바로 직전 컨텍스트의 LexicalEnvironment 정보를 참조\n\n호이스팅은 코드 해석을 좀 더 수월하게 하기 위해 environmentRecord의 수집 과정을 추상화한 개념으로, 실행 컨텍스트가 관여하는 코드 집단의 최상단으로 이들을 ‘끌어올린다’고 해석하는 것이다. 변수 선언과 값 할당이 동시에 이뤄진 문장은 ‘선언부’만을 호이스팅하고, 할당 과정은 원래 자리에 남아있게 되는데, 여기서 함수 선언문과 함수 표현식의 차이가 발생한다.\n스코프는 변수의 유효범위를 말한다. outerEnvironmentReference는 해당 함수가 선언된 위치의 LexicalEnvironment를 참조한다. 코드상에서 어떤 변수에 접근하려고 하면 현재 컨텍스트의 LexicalEnvironment를 탐색해서 발견되면 그 값을 반환하고, 발견하지 못할 경우 다시 outerEnvironmentReference에 담긴 LexicalEnvironment를 탐색하는 과정을 거친다. 전역 컨텍스트의 LexicalEnvironment까지 탐색해도 해당 변수를 찾지 못하면 undefined를 반환한다.\n전역 컨텍스트의 LexicalEnvironment에 담긴 변수를 전역변수라 하고, 그 밖의 함수에 의해 생성된 실행 컨텍스트의 변수들은 모두 지역변수이다.\nthis에는 실행 컨텍스트를 활성화하는 당시에 지정된 this가 저장된다. 함수를 호출하는 방법에 따라 그 값이 달라지는데, 지정되지 않은 경우에는 전역 객체가 저장된다.\n","dateCreated":"2020-02-16T13:35:04+09:00","dateModified":"2020-02-16T16:36:40+09:00","datePublished":"2020-02-16T13:35:04+09:00","description":"실행 컨텍스트는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체로, 자바스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 개념이다. 자바스크립트는 어떤 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어올리고(호이스팅), 외부 환경 정보를 구성하고, this 값을 설정하는 등의 동작을 수행하는데, 이로 인해 다른 언어에서는 발견할 수 없는 특이한 현상들이 발생한다.","headline":"[Javascript] 실행 컨텍스트","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://cok2exe.github.io/2020/02/16/Javascript-실행-컨텍스트/"},"publisher":{"@type":"Organization","name":"dajyu","sameAs":["https://github.com/cok2exe","http://stackoverflow.com/cok2exe"],"image":"cat.jpeg","logo":{"@type":"ImageObject","url":"cat.jpeg"}},"url":"https://cok2exe.github.io/2020/02/16/Javascript-실행-컨텍스트/","keywords":"Javascript, 실행 컨텍스트"}</script>
    <meta name="description" content="실행 컨텍스트는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체로, 자바스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 개념이다. 자바스크립트는 어떤 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어올리고(호이스팅), 외부 환경 정보를 구성하고, this 값을 설정하는 등의 동작을 수행하는데, 이로 인해 다른 언어에서는 발견할 수 없는">
<meta name="keywords" content="Javascript,실행 컨텍스트">
<meta property="og:type" content="blog">
<meta property="og:title" content="[Javascript] 실행 컨텍스트">
<meta property="og:url" content="https://cok2exe.github.io/2020/02/16/Javascript-실행-컨텍스트/index.html">
<meta property="og:site_name" content="공부방">
<meta property="og:description" content="실행 컨텍스트는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체로, 자바스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 개념이다. 자바스크립트는 어떤 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어올리고(호이스팅), 외부 환경 정보를 구성하고, this 값을 설정하는 등의 동작을 수행하는데, 이로 인해 다른 언어에서는 발견할 수 없는">
<meta property="og:locale" content="ko">
<meta property="og:updated_time" content="2020-02-16T07:36:40.128Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[Javascript] 실행 컨텍스트">
<meta name="twitter:description" content="실행 컨텍스트는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체로, 자바스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 개념이다. 자바스크립트는 어떤 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어올리고(호이스팅), 외부 환경 정보를 구성하고, this 값을 설정하는 등의 동작을 수행하는데, 이로 인해 다른 언어에서는 발견할 수 없는">
    
    
        
    
    
        <meta property="og:image" content="https://cok2exe.github.io/assets/images/cat.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            공부방
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="링크 열기: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/cat.jpeg" alt="저자 이미지"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="저자에 대해 더 알아보기"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/cat.jpeg" alt="저자 이미지"/>
                </a>
                <h4 class="sidebar-profile-name">dajyu</h4>
                
                    <h5 class="sidebar-profile-bio"><p>혼잣말 공부러(코드사냥꾼)</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="Home"
                        >
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                            title="About"
                        >
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/cok2exe" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="http://stackoverflow.com/cok2exe" target="_blank" rel="noopener" title="Stack Overflow">
                    
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            [Javascript] 실행 컨텍스트
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2020-02-16T13:35:04+09:00">
	
		    2020/02/16
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/Javascript/">Javascript</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>실행 컨텍스트는 <code>실행할 코드에 제공할 환경 정보들을 모아놓은 객체</code>로, 자바스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 개념이다. 자바스크립트는 어떤 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어올리고(호이스팅), 외부 환경 정보를 구성하고, <code>this</code> 값을 설정하는 등의 동작을 수행하는데, 이로 인해 다른 언어에서는 발견할 수 없는 특이한 현상들이 발생한다.</p>
<a id="more"></a>

<h3 id="1-실행-컨텍스트란"><a href="#1-실행-컨텍스트란" class="headerlink" title="1. 실행 컨텍스트란?"></a>1. 실행 컨텍스트란?</h3><ul>
<li>스택: 출입구가 하나뿐인 깊은 우물 같은 데이터 구조. 비어있는 스택에 순서대로 데이터 a,b,c,d를 저장했다면, 꺼낼 때는 반대로 d,c,b,a의 순서로 꺼낼 수 밖에 없다. 100개만 저장할 수 있는 우물에 100개가 넘는 데이터를 넣으려고 하면 넘칠 수밖에 없음 =&gt; 오버플로우!</li>
<li>큐: 양쪽이 모두 열려있는 파이프를 떠올리면 됨. 종류에 따라 양쪽 모두 입력과 출력이 가능한 큐도 있으나 보통은 한쪽은 입력만, 다른 한쪽은 출력만 담당하는 구조를 말한다. a,b,c,d를 넣으면 a,b,c,d 순서대로 꺼낼 수 있음.</li>
</ul>
<p>동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보들을 모아 실행 컨텍스트를 구성하고, 이를 콜 스택에 쌓아올렸다가, 가장 위에 쌓여있는 컨텍스트와 관련 있는 코드들을 실행하는 식으로 전체 코드의 환경과 순서를 보장한다. 여기서 ‘동일한 환경’, 즉 하나의 실행 컨텍스트를 구성할 수 있는 방법으로 전역공간, eval() 함수, 함수 등이 있다.</p>
<p>우리가 흔히 실행 컨텍스트를 구성하는 방법은 함수를 실행하는 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ------------------------- (1)</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  inner(); <span class="comment">// -------------- (2)</span></span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line">outer(); <span class="comment">// ---------------- (3)</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>처음 자바스크립트 코드를 실행하는 순간(1) 전역 컨텍스트가 콜 스택에 담긴다. 전역 컨텍스트라는 개념은 일반적인 실행 컨텍스트와 특별히 다를 것이 없다. 최상단의 공간은 코드 내부에서 별도의 실행 명령이 없어도 브라우저에서 자동으로 실행하므로 자바스크립트 파일이 열리는 순간 전역 컨텍스트가 활성화된다고 이해하면 된다.</p>
<p>전역 컨텍스트 외에 다른 덩어리가 없으므로 전역 컨텍스트와 관련된 코드들을 순차로 진행하다가 (3)에서 outer 함수를 호출하면 자바스크립트 엔진은 outer에 대한 환경 정보를 수집해서 outer 실행 컨텍스트를 생성한 후 콜 스택에 담는다. 콜 스택의 맨 위에 outer 실행 컨텍스트가 놓인 상태가 됐으므로 전역 컨텍스트와 관련된 코드의 실행을 일시중단하고 대신 outer 실행 컨텍스트와 관련된 코드, 즉 outer 함수 내부의 코드들을 순차로 실행한다.</p>
<p>다시 (2)에서 inner 함수의 신행 컨텍스트가 콜 스택의 가장 위에 담기면 outer 콘텍스트와 관련된 코드의 실행을 중단하고 inner 함수 내부의 코드를 순서대로 진행할 것이다.</p>
<p>스택 구조를 잘 생각해보면 한 실행 컨텍스트가 콜 스택의 맨 위에 쌓이는 순간이 곧 현재 실행할 코드에 관여하게 되는 시점임을 알 수 있다. 기존의 컨텍스트는 새로 쌓인 컨텍스트보다 아래에 위치할 수밖에 없기 때문이다. 이렇게 어떤 실행 컨텍스트가 활성화될 때 자바스크립트 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는 데 필요한 환경 정보들을 수집해서 실행 컨텍스트 객체에 저장한다. 이 객체는 자바스크립트 엔진이 활용할 목적으로 생성할 뿐 개발자가 코드를 통해 확인할 수는 없다. 여기에 담기는 정보들을 다음과 같다.</p>
<ul>
<li>VariableEnvironment: 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보, 선언 시점의 LexicalEnvironment의 스냅샷으로, 변경사항은 반영되지 않음.</li>
<li>LexicalEnvironment: 처음에는 VariableEnvironment와 같지만 변경 사항이 실시간으로 반영됨</li>
<li>ThisBinding: this 식별자가 바라봐야 할 대상 객체</li>
</ul>
<hr>
<h3 id="2-VariableEnvironment"><a href="#2-VariableEnvironment" class="headerlink" title="2. VariableEnvironment"></a>2. VariableEnvironment</h3><p>VariableEnvironment에 담기는 내용은 LexicalEnvironment와 같지만 최초 실행 시의 스냅샷을 유지한다는 점이 다르다. 실행 컨텍스트를 생성할 때 VariableEnvironment에 정보를 먼저 담은 다음, 이를 그대로 복사해서 LexicalEnvironment를 만들고, 이후에는 LexicalEnvironment를 주로 활용하게 된다.</p>
<p>VariableEnvironment와 LexicalEnvironment의 내부는 environmentRecord와 outer-EnvironmentReference로 구성돼 있다. 초기화 과정 중에는 사실상 완전히 동일하고 이후 코드 진행에 따라 서로 달라지게 됨.</p>
<hr>
<h3 id="3-LexicalEnvironment"><a href="#3-LexicalEnvironment" class="headerlink" title="3. LexicalEnvironment"></a>3. LexicalEnvironment</h3><blockquote>
<p>현재 컨텍스트의 내부에는 a, b, c와 같은 식별자들이 있고 그 외부 정보는 D를 참조하도록 구성돼 있다.</p>
<p>컨텍스트를 구성하는 환경 정보들을 사전에서 접하는 느낌으로 모아놓은 것.</p>
</blockquote>
<h4 id="3-1-environmentRecord와-호이스팅"><a href="#3-1-environmentRecord와-호이스팅" class="headerlink" title="3-1. environmentRecord와 호이스팅"></a>3-1. environmentRecord와 호이스팅</h4><p>environmentRecord<br>에는 현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장된다. 컨텍스트를 구성하는 함수에 지정된 매개변수 식별자, 선언된 함수가 있을 경우 그 함수 자체, var로 선언된 변수의 식별자 등이 식별자에 해당된다. 컨텍스트 내부 전체를 처음부터 끝까지 훑어나가며 순서대로 수집한다.</p>
<blockquote>
<p>코드가 실행되기 전임에도 불구하고 자바스크립트 엔진은 이미 해당 환경에 속한 코드의 변수명들을 모두 알고 있게 되는 셈이다.</p>
<p>여기서 등장한 개념이 바로 ‘호이스팅’ 이다.</p>
</blockquote>
<p><strong>호이스팅 규칙</strong></p>
<p>environmentRecord에는 매개변수의 이름, 함수 선언, 변수명 등이 담긴다.</p>
<p>[예제 2-2 매개변수와 변수에 대한 호이스팅(1) - 원본 코드]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params">x</span>) </span>&#123;  <span class="comment">// 수집 대상 1(매개 변수)</span></span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// (1)</span></span><br><span class="line">  <span class="keyword">var</span> x;          <span class="comment">// 수집 대상 2(변수 선언)</span></span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// (2)</span></span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">2</span>;      <span class="comment">// 수집 대상 3(변수 선언)</span></span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// (3)</span></span><br><span class="line">&#125;</span><br><span class="line">a(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>우선 호이스팅이 되지 않았을 때 (1), (2), (3)에서 어떤 값들이 출력될지를 예상해 보자. (1)에는 1, (2)에는 undefined, (3)에는 2가 출력될 것이다.</p>
<p>실제로는 어떤 결과가 나올까?</p>
<p>예제 2-2처럼 인자들과 함께 함수를 호출한 경우의 동작을 살펴보면, arguments에 전달된 인자를 담는 것을 제외하면 예제 2-3처럼 코드 내부에서 변수를 선언한 것과 다른 점이 없다. 특히 LexicalEnvironment 입장에서는 완전히 같다. 그러니까 인자를 함수 내부의 다른 코드보다 먼저 선언 및 할당이 이뤄진 것으로 간주할 수 있다.</p>
<p>[예제 2-3 매개변수와 변수에 대한 호이스팅(2) - 매개변수를 변수 선언/할당과 같다고 간주해서 변환한 상태]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;      <span class="comment">// 수집 대상 1(매개 변수)</span></span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// (1)</span></span><br><span class="line">  <span class="keyword">var</span> x;          <span class="comment">// 수집 대상 2(변수 선언)</span></span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// (2)</span></span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">2</span>;      <span class="comment">// 수집 대상 3(변수 선언)</span></span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// (3)</span></span><br><span class="line">&#125;</span><br><span class="line">a()</span><br></pre></td></tr></table></figure>

<p>이 상태에서 변수 정보를 수집하는 과정, 즉 호이스팅을 처리해 보자. environmentRecord는 현재 실행될 컨텍스트의 대상 코드 내에 어떤 식별자들이 있는지에만 관심이 있고, 각 식별자에 어떤 값이 할당될 것인지는 관심이 없다. 따라서 변수를 호이스팅할 때 변수명만 끌어올리고 할당 과정은 원래 자리에 그대로 남겨둔다. 매개변수의 경우도 마찬가지이다. environmentRecord의 관심사에 맞춰 수집 대상 1,2,3을 순서대로 끌어올리고 나면 다음과 같은 형태로 바뀐다.</p>
<p>[예제 2-4 매개변수와 변수에 대한 호이스팅(3) - 호이스팅을 마친 상태]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x;          <span class="comment">// 수집 대상 1의 변수 선언 부분</span></span><br><span class="line">  <span class="keyword">var</span> x;          <span class="comment">// 수집 대상 2의 변수 선언 부분</span></span><br><span class="line">  <span class="keyword">var</span> x;          <span class="comment">// 수집 대상 3의 변수 선언 부분</span></span><br><span class="line"></span><br><span class="line">  x = <span class="number">1</span>;      <span class="comment">// 수집 대상 1의 할당 부분</span></span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// (1)</span></span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// (2)</span></span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">2</span>;      <span class="comment">// 수집 대상 3의 할당 부분</span></span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// (3)</span></span><br><span class="line">&#125;</span><br><span class="line">a(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><strong>함수 선언문과 함수 표현식</strong></p>
<p>모두 함수를 새롭게 정의할 때 쓰이는 방식이다. 그중 함수 선언문은 function 정의부만 존재하고 별도의 할당 명령이 없는 것을 의미하고, 반대로 함수 표현식은 정의한 function을 별도의 변수에 할당하는 것을 의미한다. 함수 선언문의 경우 반드시 함수명이 정의돼 있어야 하는 반면, 함수 표현식은 없어도 된다. 함수명을 정의한 함수 표현식을 ‘기명 함수 표현식’, 정의하지 않은 것을 ‘익명 함수 표현식’이라고 부르기도 하는데, 일반적으로 함수 표현식은 익명 함수 표현식을 말한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 함수 선언문. 함수명 a가 곧 변수명.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; <span class="comment">// (익명) 함수 표현식. 변수명 b가 곧 함수명.</span></span><br><span class="line">b();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="function"><span class="keyword">function</span> <span class="title">d</span> (<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 기명 함수 표현식. 변수명은 c. 함수명은 d.</span></span><br><span class="line">c();</span><br><span class="line">d(); <span class="comment">// 에러</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>기명 함수 표현식은 주의할 점이 하나 있다. 바로 외부에서는 함수명으로 함수를 호출할 수 없다는 점이다. 함수명은 오직 함수 내부에서만 접근할 수 있다.</p>
<p>함수 내부에서 재귀함수를 호출하는 용도로 함수명을 쓸 수 있다.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(multiply(<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">a, b</span>) </span>&#123; <span class="comment">// 함수 선언문 sum</span></span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> multiply = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123; <span class="comment">// 함수 표현식 multiply</span></span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>실행 컨텍스트의 LexicalEnvironment는 두 가지 정보를 수집하는데, 여기서는 그중에서 environmentRecord의 정보 수집 과정에서 발생하는 호이스팅을 살펴보는 중이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">a, b</span>) </span>&#123; <span class="comment">// 함수 선언문 전체를 호이스팅한다.</span></span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> multiply;                   <span class="comment">// 변수는 선언부만 끌어올린다.</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(multiply(<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">multiply = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;    <span class="comment">// 변수의 할당부는 원래 자리에 남겨둔다.</span></span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>함수 선언문은 전체를 호이스팅한 반면 함수 표현식은 변수 선언부만 호이스팅했다. 함수도 하나의 값으로 취급할 수 있다는 것이 바로 이런 것이다. 함수를 다른 변수에 값으로써 ‘할당’한 것이 곧 함수 표현식이다. 여기서 함수 선언문과 함수 표현식의 극적인 차이가 발생한다.</p>
<p>sum 함수는 선언 전에 호출해도 아무 문제 없이 실행된다. </p>
<p>전역 컨텍스트가 활성화될 때 전역공간에 선언된 함수들이 모두 가장 위로 끌어올려진다. 동일한 변수명에 서로 다른 값을 할당할 경우 나중에 할당한 값이 먼저 할당한 값을 덮어씌운다. 따라서 코드를 실행하는 중에 실제로 호출되는 함수는 오직 마지막에 할당한 함수, 즉 맨 마지막에 선언된 함수 뿐이다.</p>
<blockquote>
<p>상대적으로 함수 표현식이 함수 선언문보다 안전하다.</p>
</blockquote>
<h4 id="3-2-스코프-스코프-체인-outerEnvironmentReference"><a href="#3-2-스코프-스코프-체인-outerEnvironmentReference" class="headerlink" title="3-2. 스코프, 스코프 체인, outerEnvironmentReference"></a>3-2. 스코프, 스코프 체인, outerEnvironmentReference</h4><p>스코프(scope)란 식벼자에 대한 유효범위이다. ES5까지의 자바스크립트는 특이하게도 전역공간을 제외하면 오직 함수에 의해서만 스코프가 생선된다. 이러한 ‘식별자의 유효범위’를 안에서부터 바깥으로 차례로 검색해나가는 것을 스코프 체인이라고 한다. 그리고 이를 가능케 하는 것이 바로 LexicalEnvironment의 두 번째 수집 자료인 outerEnvironmentReference이다.</p>
<p><strong>스코프 체인</strong></p>
<p>outerEnvironmentReference는 현재 호출된 함수가 <code>선언될 당시</code>의 LexicalEnvironment를 참조한다. ‘선언하다’라는 행위가 실제로 일어날 수 있는 시점이란 콜 스택 상에서 어떤 실행 컨텍스트가 활성화된 상태일 때뿐이다. 어떤 함수를 선언(정의)하는 행위 자체도 하나의 코드에 지나지 않으며, 모든 코드는 실행 컨텍스트가 활성화 상태일 때 실행되기 때문이다.</p>
<p>예를 들어, A 함수 내부에 B 함수를 선언하고 다시 B 함수 내부에 C 함수를 선언한 경우, 함수 C의 outerEnvironmentReference는 함수 B의 LexicalEnvironment를 참조한다. 함수 B의 LexicalEnvironment에 있는 outerEnvironmentReference는 다시 함수 B가 선언되던 때(A)의 LexicalEnvironment를 참조한다. 이처럼 outerEnvironemntReference는 연결리스트 형태를 띈다. <code>선언 시점의 LexicalEnvironment</code>를 계속 찾아 올라가면 마지막엔 전역 컨텍스트의 LexicalEnvironment가 있을 것이다. 또한 각 outerEnvironmentReference는 오직 자신이 선언된 시점의 LexicalEnvironment만 참조하고 있으므로 가장 가까운 요소부터 차례대로만 접근할 수 있고 다른 순서로 접근하는 것은 불가능할 것이다. 이런 구조적 특성 덕분에 여러 스코프에서 동일한 식별자를 선언한 경우에는 <strong>무조건 스코프 체인 상에서 가장 먼저 발견된 식별자에만 접근 가능</strong>하게 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> outer = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> inner = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  inner();</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;;</span><br><span class="line">outer();</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<ul>
<li>시작: 전역 컨텍스트 활성화. 전역 컨텍스트의 environmentRecord에 { a, outer } 식별자를 저장. 전역 컨텍스트는 선언 시점이 없으므로 전역 컨텍스트의 outerEnvironmentReference에는 아무것도 담기지 않음</li>
<li>1번째, 2번째 줄: 전역 스코프에 있는 변수 a에 1을, outer에 함수 할당.</li>
<li>10번째 줄: outer 함수를 호출. 이에 따라 전역 컨텍스트의 코드는 10번째 줄에서 임시중단, outer 실행 컨텍스트가 활성화되어 2번째 줄로 이동.</li>
<li>2번째 줄: outer 실행 컨텍스트의 environmentRecord에 { inner } 식별자 저장. outerEnvironmentReference에는 outer 함수가 선언될 당시의 LexicalEnvironment가 담김. outer 함수는 전역 공간에서 선언됐으므로 전역 컨텍스트의 LexicalEnvironment 참조 복사. 이를 { GLOBAL, { a, outer } } 라고 표기. 첫 번째는 실행 컨텍스트의 이름, 두 번째는 environmentRecord 객체.</li>
<li>3번째 줄: outer 스코프에 있는 변수 inner에 함수 할당.</li>
<li>7번째 줄: inner 함수 호출. outer 실행 컨텍스트와 코드는 7번째 줄에서 임시중단. inner 실행 컨텍스트가 활성화되어 3번째 줄로 이동.</li>
<li>3번째 줄: inner 실행 컨텍스트의 environmentRecord에 { a } 식별자 저장. outerEnvironmentReference에는 inner 함수가 선언될 당시의 LexicalEnvironment 가 담김. inner 함수는 outer 함수 내부에서 선언됐으므로 outer 함수의 LexicalEnvironment, 즉 { outer, { inner } }를 참조 복사함.</li>
<li>4번째 줄: 식별자 a에 접근하고자 함. 현재 활성화 상태인 inner 컨텍스트의 environmentRecord에서 a 검색. a가 발견됐는데 아직 할당된 값이 없음. undefined 출력.</li>
<li>5번째 줄: inner 스코프에 있는 변수 a에 3 할당.</li>
<li>6번째 줄: inner 함수 실행 종료. inner 실행 컨텍스트가 콜 스택에서 제거됨. 바로 아래에 있는 outer 실행 컨텍스트가 다시 활성화되면서 중단했던 7번째 줄의 다음으로 이동.</li>
<li>8번째 줄: 식별자 a에 접근하고자 함. 이때 자바스크립트 엔진은 활성화된 실행 컨텍스트의 LexicalEnvironment에 접근. 첫 요소의 environmentRecord에서 a가 있는지 찾아보고, 없으면 outerEnvironmentReference에 있는 environmentRecord로 넘어가는 식으로 계속해서 검색함. 예제에서는 전역 LexicalEnvironment에 a가 있으니 1 반환.</li>
<li>9번째 줄: outer 함수 실행 종료. outer 실행 컨텍스트가 콜 스택에서 제거됨. 바로 아래에 있는 전역 컨텍스트가 다시 활성화 되면서 중단했던 10번째 줄의 다음 줄로 이동.</li>
<li>11번재 줄: 식별자 a에 접근. 현재 활성화 상태인 전역 컨텍스트의 environmentRecord에서 a를 검색. 바로 a 찾음 (1 출력). 이로써 모든 코드의 실행이 완료됨. 전역 컨텍스트가 콜 스택에서 제거되고 종료됨.</li>
</ul>
<p>전역 공간에서는 전역 스코프에서 생성된 변수에만 접근할 수 있다. outer 함수 내부에서는 outer 및 전역 스코프에서 생성된 변수에 접근할 수 있지만 inner 스코프 내부에서 생성된 변수에는 접근하지 못한다. inner 함수 내부에서는 inner, outer, 전역 스코프 모두에 접근할 수 있다.</p>
<p>한편 스코프 체인 상에 있는 변수라고 해서 무조건 접근 가능한 것은 아니다. 위 코드 상의 식별자 a는 전역 공간에서도 선언했고 inner 함수 내부에서도 선언했다. inner 함수 내부에서 a에 접근하려고 하면 무조건 스코프 체인 상의 첫 번째 인자, 즉 inner 스코프의 LexicalEnvironment부터 검색할 수밖에 없다. inner 스코프의 LexicalEnvironment에 a 식별자가 존재하므로 스코프 체인 검색을 더 진행하지 않고 즉시 inner LexicalEnvironment 상의 a를 반환한다. 즉, inenr 함수 내부에서 a 변수를 선언했기 때문에 전역 공간에서 선언한 동일한 이름의 a 변수에는 접근할 수 없는 셈이다. 이를 <strong>변수 은닉화</strong> 라고 한다.</p>
<p><strong>전역변수와 지역변수</strong></p>
<p>전역변수는 전역 스코프에서 선언한 a와 outer 이다. 지역 변수는 outer 함수 내부에서 선언한 inner와 inner 함수 내부에서 선언한 a 이다. 즉 전역 공간에서 선언한 변수는 전역변수이고, 함수 내부에서 선언한 변수는 무조건 지역변수이다.</p>
<blockquote>
<p>코드의 안정성을 위해 가급적 전역변수 사용을 최소화하고자 노력하는 것이 좋다.</p>
</blockquote>
<hr>
<h3 id="4-this"><a href="#4-this" class="headerlink" title="4. this"></a>4. this</h3><p>실행 컨텍스트의 thisBinding에는 this로 지정된 객체가 저장된다. 실행 컨텍스트는 활성화 당시에 this가 지정되지 않은 경우 this에는 전역 객체가 저장된다. 그밖에는 함수를 호출하는 방법에 따라 this에 저장되는 대상이 다르다.</p>
<hr>
<h3 id="5-정리"><a href="#5-정리" class="headerlink" title="5. 정리"></a>5. 정리</h3><blockquote>
<p>실행 컨텍스트는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체이다.</p>
</blockquote>
<p>🔥🔥🔥<strong>핵심 키워드</strong>🔥🔥🔥<br><code>#실행 컨텍스트</code>, <code>#LexicalEnvironment</code>, <code>#environmentRecord</code>, <code>#outerEnvironmentReference</code>, <code>#스코프</code>, <code>#전역변수</code>, <code>#지역변수</code>, <code>#this</code></p>
<p>실행 컨텍스트 객체는 활성화되는 시점에 VariableEnvironment, LexicalEnvironment, thisBinding 세 가지 정보를 수집한다.</p>
<p>실행 컨텍스트를 생성할 때는 VariableEnvironment와 LexicalEnvironment가 동일한 내용으로 구성되지만, LexicalEnvironment는 함수 실행 도중에 변경되는 사항이 즉시 반영되는 반면 VariableEnvironment는 초기 상태를 유지한다.</p>
<p>VariableEnvironment와 LexicalEnvironment은 아래 두가지로 구성돼 있음.</p>
<ul>
<li>environmentRecord: 매개변수명, 변수의 식별자, 선언한 함수의 함수명 등을 수집</li>
<li>outerEnvironmentReference: 바로 직전 컨텍스트의 LexicalEnvironment 정보를 참조</li>
</ul>
<p>호이스팅은 코드 해석을 좀 더 수월하게 하기 위해 environmentRecord의 수집 과정을 추상화한 개념으로, 실행 컨텍스트가 관여하는 코드 집단의 최상단으로 이들을 ‘끌어올린다’고 해석하는 것이다. 변수 선언과 값 할당이 동시에 이뤄진 문장은 ‘선언부’만을 호이스팅하고, 할당 과정은 원래 자리에 남아있게 되는데, 여기서 함수 선언문과 함수 표현식의 차이가 발생한다.</p>
<p>스코프는 변수의 유효범위를 말한다. outerEnvironmentReference는 해당 함수가 선언된 위치의 LexicalEnvironment를 참조한다. 코드상에서 어떤 변수에 접근하려고 하면 현재 컨텍스트의 LexicalEnvironment를 탐색해서 발견되면 그 값을 반환하고, 발견하지 못할 경우 다시 outerEnvironmentReference에 담긴 LexicalEnvironment를 탐색하는 과정을 거친다. 전역 컨텍스트의 LexicalEnvironment까지 탐색해도 해당 변수를 찾지 못하면 undefined를 반환한다.</p>
<p>전역 컨텍스트의 LexicalEnvironment에 담긴 변수를 전역변수라 하고, 그 밖의 함수에 의해 생성된 실행 컨텍스트의 변수들은 모두 지역변수이다.</p>
<p>this에는 실행 컨텍스트를 활성화하는 당시에 지정된 this가 저장된다. 함수를 호출하는 방법에 따라 그 값이 달라지는데, 지정되지 않은 경우에는 전역 객체가 저장된다.</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">태그</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/Javascript/">Javascript</a> <a class="tag tag--primary tag--small t-link" href="/tags/실행-컨텍스트/">실행 컨텍스트</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a
                        class="post-action-btn btn btn--disabled"
                        aria-hidden="true"
                    >
                        
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/02/09/Javascript-데이터-타입-2/"
                    data-tooltip="[Javascript] 데이터 타입 (2)"
                    aria-label="다음: [Javascript] 데이터 타입 (2)"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cok2exe.github.io/2020/02/16/Javascript-실행-컨텍스트/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cok2exe.github.io/2020/02/16/Javascript-실행-컨텍스트/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://cok2exe.github.io/2020/02/16/Javascript-실행-컨텍스트/"
                    title="Google+에 공유하기"
                    aria-label="Google+에 공유하기"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 dajyu. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a
                        class="post-action-btn btn btn--disabled"
                        aria-hidden="true"
                    >
                        
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/02/09/Javascript-데이터-타입-2/"
                    data-tooltip="[Javascript] 데이터 타입 (2)"
                    aria-label="다음: [Javascript] 데이터 타입 (2)"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cok2exe.github.io/2020/02/16/Javascript-실행-컨텍스트/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cok2exe.github.io/2020/02/16/Javascript-실행-컨텍스트/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://cok2exe.github.io/2020/02/16/Javascript-실행-컨텍스트/"
                    title="Google+에 공유하기"
                    aria-label="Google+에 공유하기"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://cok2exe.github.io/2020/02/16/Javascript-실행-컨텍스트/"
                        aria-label="Facebook에 공유하기"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Facebook에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://cok2exe.github.io/2020/02/16/Javascript-실행-컨텍스트/"
                        aria-label="Twitter에 공유하기"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Twitter에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=https://cok2exe.github.io/2020/02/16/Javascript-실행-컨텍스트/"
                        aria-label="Google+에 공유하기"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Google+에 공유하기</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/cat.jpeg" alt="저자 이미지"/>
        
            <h4 id="about-card-name">dajyu</h4>
        
            <div id="about-card-bio"><p>혼잣말 공부러(코드사냥꾼)</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Web frontend</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Asia/Seoul
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->


    




    </body>
</html>
