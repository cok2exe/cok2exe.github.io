
<!DOCTYPE html>
<html lang="ko">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="공부방">
    <title>[Javascript] 데이터 타입 (2) - 공부방</title>
    <meta name="author" content="dajyu">
    
        <meta name="keywords" content="React,Typescript,HTML,CSS,Frontend,">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"dajyu","sameAs":["https://github.com/cok2exe","http://stackoverflow.com/cok2exe"],"image":"cat.jpeg"},"articleBody":"\n불변 객체는 최근 자바스크립트 영역에서 가장 중요한 개념 중 하나이다.\n\n\n‘없음’을 나타내는 값은 두 가지가 있는데, undefined는 어떤 변수에 값이 존재하지 않을 경우를 의미하고 null은 사용자가 명시적으로 ‘없음’을 표현하기 위해 대입한 값이다.\n본래의 의미에 따라 사용자가 없음을 표현하기 위해 명시적으로 undefined를 대입하는 것은 지양하는 것이 좋다.\n\n\n\n5. 불변 객체5-1. 불변 객체를 만드는 간단한 방법불변 객체(immutable object)는 매우 중요한 기초가 되는 개념이다. 참조형 데이터의 ‘가변’은 데이터 자체가 아닌 내부 프로퍼티를 변경할 때만 성립한다. 데이터 자체를 변경하고자 하면 기본형 데이터와 마찬가지로 기존 데이터는 변하지 않는다.\n그렇다면 내부 프로퍼티를 변경할 때마다 매번 새로운 객체를 만들어 재할당하기로 규칙을 정하거나 자동으로 새로운 객체를 만드는 도구(대표적으로 immutable.js가 있음 / ES6의 spread operator, Object.assign 등도 활용 가능)를 활용한다면 객체 역시 불변성을 확보할 수 있을 것이다.\n어떤 상황에서 불변 객체가 필요할까? 값으로 전달받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 하는 경우가 종종 발생한다. 바로 이럴 때 불변 객체가 필요하다.\n[예제 1-11]\n123456789101112131415161718var user = &#123;  name: 'Jaenam',  gender: 'male'&#125;;var changeName = function (user, newName) &#123;  var newUser = user;  newUser.name = newName;  return newUser;  &#125;;var user2 = changeName(user, 'Jung');if (user !== user2) &#123;  console.log('유저 정보가 변경되었습니다.');&#125;;console.log(user.name, user2.name); // Jung Jungconsole.log(user === user2);        // true\n\n위의 예시는 객체의 가변성으로 인한 문제점을 보여주는 간단한 예시이다.\n변경 전과 변경 후에 서로 다른 객체를 바라보게 고친 코드는 아래와 같다.\n[예제 1-12]\n12345678910111213141516171819var user = &#123;  name: 'Jaenam',  gender: 'male'&#125;;var changeName = function (user, newName) &#123;  return &#123;    name: newName,    gender: user.gender  &#125;;&#125;;var user2 = changeName(user, 'Jung');if (user !== user2) &#123;  console.log('유저 정보가 변경되었습니다.'); // 유저 정보가 변경되었습니다.&#125;;console.log(user.name, user2.name); // Jaenam Jungconsole.log(user === user2);        // false\n\nchangeName 함수가 새로운 객체를 반환하도록 수정하였다. 이제 user와 user2는 서로 다른 객체이므로 안전하게 변경 전과 후를 비교할 수 있다.\n그러나, changeName 함수는 새로운 객체를 만들면서 변경할 필요가 없는 기존 객체의 프로퍼티(gender)를 하드코딩으로 입력했다. 이런 식으로는 대상 객체에 정보가 많을수록, 변경해야 할 정보가 많을수록 사용자가 입력하는 수고가 늘어날 것이다. 이런 방식보다는 대상 객체의 프로퍼티 개수에 상관없이 모든 프로퍼티를 복사하는 함수를 만드는 편이 좋을 것이다.\n1234567var copyObject = function (target) &#123;  var result = &#123;&#125;;  for (var prop in target) &#123;    result[prop] = target[prop];  &#125;  return result;&#125;;\n\n위의 copyObject를 이용하여 [예제 1-11]를 수정해보면 아래와 같다.\n12345678910111213var user = &#123;  name: 'Jaenam',  gender: 'male'&#125;;var user2 = copyObject(user);user2.name = 'Jung';if (user !== user2) &#123;  console.log('유저 정보가 변경되었습니다.'); // 유저 정보가 변경되었습니다.&#125;;console.log(user.name, user2.name); // Jaenam Jungconsole.log(user === user2);        // false\n\n5-2. 얕은 복사와 깊은 복사얕은 복사는 바로 아래 단계의 값만 복사하는 방법이고, 깊은 복사는 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법이다. [예제 1-12]의 copyObject 함수는 얕은 복사만 수행했다. 이 말은 중첩된 객체에서 참조형 데이터가 저장된 프로퍼티를 복사할 때 그 주솟값만 복사한다는 의미이다. 그러면 해당 프로퍼티에 대해 원본과 사본이 모두 동일한 참조형 데이터의 주소를 가리키게 된다. 사본을 바꾸면 원본도 바뀌고, 원본을 바꾸면 사본도 바뀐다.\n[예제 1-14 중첩된 객체에 대한 얕은 복사]\n 123456789101112131415161718var user = &#123;  name: 'Jaenam',  urls: &#123;    portfolio: 'http://github.com/abc',    blog: 'http://blog.com',    facebook: 'http://facebook.com/abc'  &#125;&#125;;var user2 = copyObject(user);user2.name = 'Jung',console.log(user.name === user2.name); // falseuser.urls.portfolio = 'http://portfolio.com';console.log(user.urls.portfolio === user2.urls.portfolio); // trueuser2.urls.blog = '';console.log(user.urls.blog === user2.urls.blog); // true\n\n11번째 줄에서 사본인 user2의 name 프로퍼티를 바꿔도 user의 name 프로퍼티는 바뀌지 않았다. 반면 14번째 줄과 17번째 줄에서는 원본과 사본 중 어느쪽을 바꾸더라도 다른 한쪽의 값도 함께 바뀐 것을 확인할 수 있다.\n즉 user 객체에 직접 속한 프로퍼티에 대해서는 복사해서 완전히 새로운 데이터가 만들어진 반면, 한 단계 더 들어간 urls의 내부 프로퍼티들은 기존 데이터를 그대로 참조하는 것이다.\n[예제 1-15 중첩된 객체에 대한 깊은 복사]\n12345678var user2 = copyObject(user);user2.urls = copyObject(user.urls);user.urls.portfolio = 'http://portfolio.com';console.log(user.urls.portfolio === user2.urls.portfolio); // falseuser2.urls.blog = '';console.log(user.urls.blog === user2.urls.blog) // false\n\n이제 urls 프로퍼티의 내부까지 복사해서 새로운 데이터가 만들어졌으므로 5번째 줄과 8번째 줄에서 값이 서로 다르다는 결과를 얻을 수 있다.\n어떤 객체를 복사할 때 객체 내부의 모든 값을 복사해서 완전히 새로운 데이터를 만들고자 할 때, 객체의 프로퍼티 중에서 그 값이 기본형 데이터일 경우에는 그대로 복사하면 되지만, 참조형 데이터는 다시 그 내부의 프로퍼티들을 복사해야 한다. 이 과정을 참조형 데이터가 있을 때마다 재귀적으로 수행해야만 비로소 깊은 복사가 되는 것이다.\n[예제 1-16 객체의 깊은 복사를 수행하는 범용 함수]\n1234567891011var copyObjectDeep = function (target) &#123;  var result = [];  if (typeof target === 'object' &amp;&amp; target !== null) &#123;    for (var prop in target) &#123;      result[prop] = copyObjectDeep(target[prop]);    &#125;  &#125; else &#123;    result = target;  &#125;  return result;&#125;;\n\n[예제 1-17 깊은 복사 결과 확인]\n12345678910111213141516var obj = &#123;  a: 1,  b: &#123;    c: null,    d: [1, 2]  &#125;&#125;;var obj2 = copyObjectDeep(obj);obj2.a = 3;obj2.b.c = 4;obj.b.d[1] = 3;console.log(obj);   // &#123; a: 1, b: &#123; c: null, d: [1, 3] &#125; &#125;console.log(obj2);  // &#123; a: 3, b: &#123; c: 4, d: [1, 2] &#125; &#125;\n\n끝으로 간단하게 깊은 복사를 처리할 수 있는 다른 방법 하나를 더 소개한다. 원리도 단순하다. 객체를 JSON 문법으로 표현된 문자열로 전환했다가 다시 JSON 객체로 바꾸는 것이다. 이 방법은 단순함에도 불구하고 잘 동작한다.\n[예제 1-18 JSON을 활용한 간단한 깊은 복사]\n1234567891011121314151617181920var copyObjectViaJSON = function (target) &#123;  return JSON.parse(JSON.stringify(target));&#125;;var obj = &#123;  a: 1,  b: &#123;    c: null,    d: [1, 2],    func1: function () &#123; console.log(3); &#125;  &#125;,  func2: function () &#123; console.log(4); &#125;&#125;;var obj2 = copyObjectViaJSON(obj);obj2.a = 3;obj2.b.c = 4;obj.b.d[1] = 3;console.log(obj);   // &#123; a: 1, b: &#123; c: null, d: [1, 3], func1: f() &#125;, func2: f() &#125;console.log(obj2);  // &#123; a: 3, b: &#123; c: 4, d: [1, 2], func1: f() &#125;, func2: f() &#125;\n\n\n6. undefined와 null자바스크립트에는 ‘없음’을 나타내는 값이 두 가지가 있다. 바로 undefined와 null이다. 두 값의 의미는 같은 것 같지만 미세하게 다르고, 사용하는 목적 또한 다르다.\n우선 undefined는 사용자가 명시적으로 지정할 수도 있지만 값이 존재하지 않을 때 자바스크립트 엔진이 자동으로 부여하는 경우도 있다.\n자바스크립트 엔진은 사용자가 어떤 값을 지정할 것이라고 예상되는 상황임에도 실제로는 그렇게 하지 않았을 때 undefined를 반환한다. 다음 세 경우가 이에 해당한다.\n\n값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때\n객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때\nreturn 문이 없거나 호출되지 않는 함수의 실행 결과\n\n[예제 1-19 자동으로 undefined를 부여하는 경우]\n123456789var a;console.log(a); // undefinedvar obj = &#123; a: 1 &#125;;console.log(obj.b); // undefinedvar func = function() &#123;&#125;;var c = func();console.log(c); // undefined\n\n값을 대입하지 않은 경우에 대해 배열의 경우에는 조금 특이한 동작을 확인할 수 있다.\n123456789var arr1 = [];arr1.length = 3;console.log(arr1);    // [empty x 3]var arr2 = new Array(3);console.log(arr2);    // [empty x 3]var arr3 = [undefined, undefined, undefined];console.log(arr3);    // [undefined, undefined, undefined]\n\n3번째 줄과, 6번째 줄의 출력 결과는 문자 그대로 어떤 값도, 심지어 undefined조차도 할당돼 있지 않음을 의미한다.\n이처럼 비어있는 요소와 undefined를 할당한 요소는 출력 결과부터 다르다. 비어있는 요소는 순회와 관련된 많은 배열 메서드들의 순회 대상에서 제외된다.\n123456789101112131415var arr1 = [undefined, 1];var arr2 = [];arr2[1] = 1;arr1.forEach(function (v, i) &#123; console.log(v, i); &#125;);      // undefined 0 / 1 1arr2.forEach(function (v, i) &#123; console.log(v, i); &#125;);      // 1 1arr1.map(function (v, i) &#123; return v + i; &#125;);               // [NaN, 2]arr2.map(function (v, i) &#123; return v + i; &#125;);               // [empty, 2]arr1.filter(function (v) &#123; return !v; &#125;);                  // [undefined]arr2.filter(function (v) &#123; return !v; &#125;);                  // []arr1.reduce(function (p, c, i) &#123; return p + c + i; &#125;, ''); // undefined011arr2.reduce(function (p, c, i) &#123; return p + c + i; &#125;, ''); // 11\n\n예제 arr1은 undefined와 1을 직접 할당한 반면 arr2는 빈 배열의 인덱스 1에 값 1을 할당했다. 이 두 배열은 배열의 각 요소를 순회하는 것을 기본으로 추가적인 기능을 수행하는 메서드들, 즉 forEach, map, filter, reduce 등에서 서로 다른 결과를 보인다. 사용자가 직접 undefined를 할당한 arr1에 대해서는 일반적으로 알고 있는 대로 배열의 모든 요소를 순회해서 결과를 출력한다. 그러나 arr2에 대한 결과를 보면, 각 메서드들이 비어 있는 요소에 대해서는 어떠한 처리도 하지 않고 건너뛰었음을 알 수 있다.\n존재하지 않는 프로퍼티에 대해서는 순회할 수 없는 것이 당연하다. 배열은 무조건 length 프로퍼티의 개수만큼 빈 공간을 확보하고 각 공간에 인덱스를 이름으로 지정할 것이라고 생각하기 쉽지만, 실제로는 객체와 마찬가지로 특정 인덱스에 값을 지정할 때 비로소 빈 공간을 확보하고 인덱스를 이름으로 지정하고 데이터의 주솟값을 저장하는 등의 동작을 한다. 즉, 값이 지정되지 않은 인덱스는 ‘아직은 존재하지 않는 프로퍼티’에 지나지 않는 것이다.\n값으로써 어딘가에 할당된 undefined는 실존하는 데이터인 반면, 자바스크립트 엔진이 반환해주는 undefined는 문자 그대로 값이 없음을 나타내는 것이다.\n\n보통 ‘var a’라는 구문에 의해 식별자 a에 자동으로 undefined&gt;가 ‘할당된다’고 알려져 있지만, 자바스크립트가 실제로 그렇게 동작하는 것은 아니다.정확히는 아무것도 할당하지 않고 끝나며, 이후 변수 a에 접근하고자 할 때 비로소 undefined를 반환하는 것이 맞다.\n\n‘비어있음’을 명시적으로 나타내고 싶을 때는 undefined 대신 null을 쓰면 된다. null은 애초에 이런 용도로 만든 데이터 타입이다. 이런 규칙을 따르는 한 undefined는 오직 ‘값을 대입하지 않은 변수에 접근하고자 할 때 자바스크립트 엔진이 반환해주는 값’으로서만 존재할 수 있다.\n추가로 null은 한 가지 주의할 점이 있다. 바로 typeof null이 object라는 점이다. 이는 자바스크립트 자체 버그이다.(히익..) 따라서 어떤 변수의 값이 null인지 여부를 판별하기 위해서는 typeof 대신 다른 방식으로 접근해야 한다.\n12345678var n = null;console.log(typeof n);        // objectconsole.log(n == undefined);  // trueconsole.log(n == null);       // trueconsole.log(n === undefined); // falseconsole.log(n === null);      // true\n\n4번째 줄과 같이 동등 연산자(==)로 비교할 경우 null과 undefined가 서로 같다고 판단한다. 따라서 어떤 변수가 실제로 null인지 아니면 undefined인지는 동등 연산자로 비교해서는 알 수 없다. 7번째 8번째 줄과 같이 일치 연산자(===)를 써야만 정확히 판별할 수 있다.\n참고 : 코어 자바스크립트\n","dateCreated":"2020-02-09T15:17:31+09:00","dateModified":"2020-02-09T16:50:03+09:00","datePublished":"2020-02-09T15:17:31+09:00","description":"\n불변 객체는 최근 자바스크립트 영역에서 가장 중요한 개념 중 하나이다.\n\n\n‘없음’을 나타내는 값은 두 가지가 있는데, undefined는 어떤 변수에 값이 존재하지 않을 경우를 의미하고 null은 사용자가 명시적으로 ‘없음’을 표현하기 위해 대입한 값이다.\n본래의 의미에 따라 사용자가 없음을 표현하기 위해 명시적으로 undefined를 대입하는 것은 지양하는 것이 좋다.\n","headline":"[Javascript] 데이터 타입 (2)","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://cok2exe.github.io/2020/02/09/Javascript-데이터-타입-2/"},"publisher":{"@type":"Organization","name":"dajyu","sameAs":["https://github.com/cok2exe","http://stackoverflow.com/cok2exe"],"image":"cat.jpeg","logo":{"@type":"ImageObject","url":"cat.jpeg"}},"url":"https://cok2exe.github.io/2020/02/09/Javascript-데이터-타입-2/","keywords":"Javascript, 데이터 타입"}</script>
    <meta name="description" content="불변 객체는 최근 자바스크립트 영역에서 가장 중요한 개념 중 하나이다.   ‘없음’을 나타내는 값은 두 가지가 있는데, undefined는 어떤 변수에 값이 존재하지 않을 경우를 의미하고 null은 사용자가 명시적으로 ‘없음’을 표현하기 위해 대입한 값이다. 본래의 의미에 따라 사용자가 없음을 표현하기 위해 명시적으로 undefined를 대입하는 것은 지">
<meta name="keywords" content="Javascript,데이터 타입">
<meta property="og:type" content="blog">
<meta property="og:title" content="[Javascript] 데이터 타입 (2)">
<meta property="og:url" content="https://cok2exe.github.io/2020/02/09/Javascript-데이터-타입-2/index.html">
<meta property="og:site_name" content="공부방">
<meta property="og:description" content="불변 객체는 최근 자바스크립트 영역에서 가장 중요한 개념 중 하나이다.   ‘없음’을 나타내는 값은 두 가지가 있는데, undefined는 어떤 변수에 값이 존재하지 않을 경우를 의미하고 null은 사용자가 명시적으로 ‘없음’을 표현하기 위해 대입한 값이다. 본래의 의미에 따라 사용자가 없음을 표현하기 위해 명시적으로 undefined를 대입하는 것은 지">
<meta property="og:locale" content="ko">
<meta property="og:updated_time" content="2020-02-09T07:50:03.944Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[Javascript] 데이터 타입 (2)">
<meta name="twitter:description" content="불변 객체는 최근 자바스크립트 영역에서 가장 중요한 개념 중 하나이다.   ‘없음’을 나타내는 값은 두 가지가 있는데, undefined는 어떤 변수에 값이 존재하지 않을 경우를 의미하고 null은 사용자가 명시적으로 ‘없음’을 표현하기 위해 대입한 값이다. 본래의 의미에 따라 사용자가 없음을 표현하기 위해 명시적으로 undefined를 대입하는 것은 지">
    
    
        
    
    
        <meta property="og:image" content="https://cok2exe.github.io/assets/images/cat.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            공부방
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="링크 열기: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/cat.jpeg" alt="저자 이미지"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="저자에 대해 더 알아보기"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/cat.jpeg" alt="저자 이미지"/>
                </a>
                <h4 class="sidebar-profile-name">dajyu</h4>
                
                    <h5 class="sidebar-profile-bio"><p>혼잣말 공부러(코드사냥꾼)</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="Home"
                        >
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                            title="About"
                        >
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/cok2exe" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="http://stackoverflow.com/cok2exe" target="_blank" rel="noopener" title="Stack Overflow">
                    
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            [Javascript] 데이터 타입 (2)
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2020-02-09T15:17:31+09:00">
	
		    2020/02/09
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/Javascript/">Javascript</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <blockquote>
<p>불변 객체는 최근 자바스크립트 영역에서 가장 중요한 개념 중 하나이다.</p>
</blockquote>
<blockquote>
<p>‘없음’을 나타내는 값은 두 가지가 있는데, undefined는 어떤 변수에 값이 존재하지 않을 경우를 의미하고 null은 사용자가 명시적으로 ‘없음’을 표현하기 위해 대입한 값이다.</p>
<p>본래의 의미에 따라 사용자가 없음을 표현하기 위해 명시적으로 undefined를 대입하는 것은 지양하는 것이 좋다.</p>
</blockquote>
<a id="more"></a>

<h3 id="5-불변-객체"><a href="#5-불변-객체" class="headerlink" title="5. 불변 객체"></a>5. 불변 객체</h3><h4 id="5-1-불변-객체를-만드는-간단한-방법"><a href="#5-1-불변-객체를-만드는-간단한-방법" class="headerlink" title="5-1. 불변 객체를 만드는 간단한 방법"></a>5-1. 불변 객체를 만드는 간단한 방법</h4><p>불변 객체(immutable object)는 매우 중요한 기초가 되는 개념이다. 참조형 데이터의 ‘가변’은 데이터 자체가 아닌 내부 프로퍼티를 변경할 때만 성립한다. 데이터 자체를 변경하고자 하면 기본형 데이터와 마찬가지로 <strong>기존 데이터는 변하지 않는다.</strong></p>
<p>그렇다면 내부 프로퍼티를 변경할 때마다 매번 새로운 객체를 만들어 재할당하기로 규칙을 정하거나 자동으로 새로운 객체를 만드는 도구(대표적으로 immutable.js가 있음 / ES6의 spread operator, Object.assign 등도 활용 가능)를 활용한다면 객체 역시 불변성을 확보할 수 있을 것이다.</p>
<p>어떤 상황에서 불변 객체가 필요할까? 값으로 전달받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 하는 경우가 종종 발생한다. 바로 이럴 때 불변 객체가 필요하다.</p>
<p>[예제 1-11]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">  name: <span class="string">'Jaenam'</span>,</span><br><span class="line">  gender: <span class="string">'male'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> changeName = <span class="function"><span class="keyword">function</span> (<span class="params">user, newName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newUser = user;</span><br><span class="line">  newUser.name = newName;</span><br><span class="line">  <span class="keyword">return</span> newUser;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user2 = changeName(user, <span class="string">'Jung'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (user !== user2) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'유저 정보가 변경되었습니다.'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(user.name, user2.name); <span class="comment">// Jung Jung</span></span><br><span class="line"><span class="built_in">console</span>.log(user === user2);        <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>위의 예시는 객체의 가변성으로 인한 문제점을 보여주는 간단한 예시이다.</p>
<p>변경 전과 변경 후에 서로 다른 객체를 바라보게 고친 코드는 아래와 같다.</p>
<p>[예제 1-12]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">  name: <span class="string">'Jaenam'</span>,</span><br><span class="line">  gender: <span class="string">'male'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> changeName = <span class="function"><span class="keyword">function</span> (<span class="params">user, newName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: newName,</span><br><span class="line">    gender: user.gender</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user2 = changeName(user, <span class="string">'Jung'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (user !== user2) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'유저 정보가 변경되었습니다.'</span>); <span class="comment">// 유저 정보가 변경되었습니다.</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(user.name, user2.name); <span class="comment">// Jaenam Jung</span></span><br><span class="line"><span class="built_in">console</span>.log(user === user2);        <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>changeName 함수가 새로운 객체를 반환하도록 수정하였다. 이제 user와 user2는 서로 다른 객체이므로 안전하게 변경 전과 후를 비교할 수 있다.</p>
<p>그러나, changeName 함수는 새로운 객체를 만들면서 변경할 필요가 없는 기존 객체의 프로퍼티(gender)를 하드코딩으로 입력했다. 이런 식으로는 대상 객체에 정보가 많을수록, 변경해야 할 정보가 많을수록 사용자가 입력하는 수고가 늘어날 것이다. 이런 방식보다는 대상 객체의 프로퍼티 개수에 상관없이 모든 프로퍼티를 복사하는 함수를 만드는 편이 좋을 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> copyObject = <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">    result[prop] = target[prop];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>위의 copyObject를 이용하여 [예제 1-11]를 수정해보면 아래와 같다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">  name: <span class="string">'Jaenam'</span>,</span><br><span class="line">  gender: <span class="string">'male'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user2 = copyObject(user);</span><br><span class="line">user2.name = <span class="string">'Jung'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (user !== user2) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'유저 정보가 변경되었습니다.'</span>); <span class="comment">// 유저 정보가 변경되었습니다.</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(user.name, user2.name); <span class="comment">// Jaenam Jung</span></span><br><span class="line"><span class="built_in">console</span>.log(user === user2);        <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="5-2-얕은-복사와-깊은-복사"><a href="#5-2-얕은-복사와-깊은-복사" class="headerlink" title="5-2. 얕은 복사와 깊은 복사"></a>5-2. 얕은 복사와 깊은 복사</h4><p>얕은 복사는 바로 아래 단계의 값만 복사하는 방법이고, 깊은 복사는 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법이다. [예제 1-12]의 copyObject 함수는 얕은 복사만 수행했다. 이 말은 중첩된 객체에서 참조형 데이터가 저장된 프로퍼티를 복사할 때 그 주솟값만 복사한다는 의미이다. 그러면 해당 프로퍼티에 대해 원본과 사본이 모두 동일한 참조형 데이터의 주소를 가리키게 된다. 사본을 바꾸면 원본도 바뀌고, 원본을 바꾸면 사본도 바뀐다.</p>
<p>[예제 1-14 중첩된 객체에 대한 얕은 복사]</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">  name: <span class="string">'Jaenam'</span>,</span><br><span class="line">  urls: &#123;</span><br><span class="line">    portfolio: <span class="string">'http://github.com/abc'</span>,</span><br><span class="line">    blog: <span class="string">'http://blog.com'</span>,</span><br><span class="line">    facebook: <span class="string">'http://facebook.com/abc'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> user2 = copyObject(user);</span><br><span class="line"></span><br><span class="line">user2.name = <span class="string">'Jung'</span>,</span><br><span class="line"><span class="built_in">console</span>.log(user.name === user2.name); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">user.urls.portfolio = <span class="string">'http://portfolio.com'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(user.urls.portfolio === user2.urls.portfolio); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">user2.urls.blog = <span class="string">''</span>;</span><br><span class="line"><span class="built_in">console</span>.log(user.urls.blog === user2.urls.blog); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>11번째 줄에서 사본인 user2의 name 프로퍼티를 바꿔도 user의 name 프로퍼티는 바뀌지 않았다. 반면 14번째 줄과 17번째 줄에서는 원본과 사본 중 어느쪽을 바꾸더라도 다른 한쪽의 값도 함께 바뀐 것을 확인할 수 있다.</p>
<p>즉 user 객체에 직접 속한 프로퍼티에 대해서는 복사해서 완전히 새로운 데이터가 만들어진 반면, 한 단계 더 들어간 urls의 내부 프로퍼티들은 <strong>기존 데이터를 그대로 참조</strong>하는 것이다.</p>
<p>[예제 1-15 중첩된 객체에 대한 깊은 복사]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user2 = copyObject(user);</span><br><span class="line">user2.urls = copyObject(user.urls);</span><br><span class="line"></span><br><span class="line">user.urls.portfolio = <span class="string">'http://portfolio.com'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(user.urls.portfolio === user2.urls.portfolio); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">user2.urls.blog = <span class="string">''</span>;</span><br><span class="line"><span class="built_in">console</span>.log(user.urls.blog === user2.urls.blog) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>이제 urls 프로퍼티의 내부까지 복사해서 새로운 데이터가 만들어졌으므로 5번째 줄과 8번째 줄에서 값이 서로 다르다는 결과를 얻을 수 있다.</p>
<p>어떤 객체를 복사할 때 객체 내부의 모든 값을 복사해서 완전히 새로운 데이터를 만들고자 할 때, 객체의 프로퍼티 중에서 그 값이 <strong>기본형 데이터일 경우에는 그대로 복사하면 되지만, 참조형 데이터는 다시 그 내부의 프로퍼티들을 복사</strong>해야 한다. 이 과정을 참조형 데이터가 있을 때마다 재귀적으로 수행해야만 비로소 깊은 복사가 되는 것이다.</p>
<p>[예제 1-16 객체의 깊은 복사를 수행하는 범용 함수]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> copyObjectDeep = <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span> &amp;&amp; target !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">      result[prop] = copyObjectDeep(target[prop]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[예제 1-17 깊은 복사 결과 확인]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    c: <span class="literal">null</span>,</span><br><span class="line">    d: [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = copyObjectDeep(obj);</span><br><span class="line"></span><br><span class="line">obj2.a = <span class="number">3</span>;</span><br><span class="line">obj2.b.c = <span class="number">4</span>;</span><br><span class="line">obj.b.d[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj);   <span class="comment">// &#123; a: 1, b: &#123; c: null, d: [1, 3] &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2);  <span class="comment">// &#123; a: 3, b: &#123; c: 4, d: [1, 2] &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p>끝으로 간단하게 깊은 복사를 처리할 수 있는 다른 방법 하나를 더 소개한다. 원리도 단순하다. 객체를 JSON<br> 문법으로 표현된 문자열로 전환했다가 다시 JSON 객체로 바꾸는 것이다. 이 방법은 단순함에도 불구하고 잘 동작한다.</p>
<p>[예제 1-18 JSON을 활용한 간단한 깊은 복사]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> copyObjectViaJSON = <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(target));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    c: <span class="literal">null</span>,</span><br><span class="line">    d: [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">    func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">3</span>); &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">4</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = copyObjectViaJSON(obj);</span><br><span class="line"></span><br><span class="line">obj2.a = <span class="number">3</span>;</span><br><span class="line">obj2.b.c = <span class="number">4</span>;</span><br><span class="line">obj.b.d[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj);   <span class="comment">// &#123; a: 1, b: &#123; c: null, d: [1, 3], func1: f() &#125;, func2: f() &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2);  <span class="comment">// &#123; a: 3, b: &#123; c: 4, d: [1, 2], func1: f() &#125;, func2: f() &#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-undefined와-null"><a href="#6-undefined와-null" class="headerlink" title="6. undefined와 null"></a>6. undefined와 null</h3><p>자바스크립트에는 ‘없음’을 나타내는 값이 두 가지가 있다. 바로 undefined와 null이다. 두 값의 의미는 같은 것 같지만 미세하게 다르고, 사용하는 목적 또한 다르다.</p>
<p>우선 undefined는 사용자가 명시적으로 지정할 수도 있지만 값이 존재하지 않을 때 자바스크립트 엔진이 자동으로 부여하는 경우도 있다.</p>
<p>자바스크립트 엔진은 사용자가 어떤 값을 지정할 것이라고 예상되는 상황임에도 실제로는 그렇게 하지 않았을 때 undefined를 반환한다. 다음 세 경우가 이에 해당한다.</p>
<ol>
<li>값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때</li>
<li>객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때</li>
<li>return 문이 없거나 호출되지 않는 함수의 실행 결과</li>
</ol>
<p>[예제 1-19 자동으로 undefined를 부여하는 경우]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.b); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> c = func();</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>값을 대입하지 않은 경우에 대해 배열의 경우에는 조금 특이한 동작을 확인할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [];</span><br><span class="line">arr1.length = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr1);    <span class="comment">// [empty x 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr2);    <span class="comment">// [empty x 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr3);    <span class="comment">// [undefined, undefined, undefined]</span></span><br></pre></td></tr></table></figure>

<p>3번째 줄과, 6번째 줄의 출력 결과는 문자 그대로 어떤 값도, 심지어 undefined조차도 할당돼 있지 않음을 의미한다.</p>
<p>이처럼 <code>비어있는 요소</code>와 <code>undefined를 할당한 요소</code>는 출력 결과부터 다르다. 비어있는 요소는 순회와 관련된 많은 배열 메서드들의 순회 대상에서 제외된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="literal">undefined</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [];</span><br><span class="line">arr2[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">arr1.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">v, i</span>) </span>&#123; <span class="built_in">console</span>.log(v, i); &#125;);      <span class="comment">// undefined 0 / 1 1</span></span><br><span class="line">arr2.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">v, i</span>) </span>&#123; <span class="built_in">console</span>.log(v, i); &#125;);      <span class="comment">// 1 1</span></span><br><span class="line"></span><br><span class="line">arr1.map(<span class="function"><span class="keyword">function</span> (<span class="params">v, i</span>) </span>&#123; <span class="keyword">return</span> v + i; &#125;);               <span class="comment">// [NaN, 2]</span></span><br><span class="line">arr2.map(<span class="function"><span class="keyword">function</span> (<span class="params">v, i</span>) </span>&#123; <span class="keyword">return</span> v + i; &#125;);               <span class="comment">// [empty, 2]</span></span><br><span class="line"></span><br><span class="line">arr1.filter(<span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123; <span class="keyword">return</span> !v; &#125;);                  <span class="comment">// [undefined]</span></span><br><span class="line">arr2.filter(<span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123; <span class="keyword">return</span> !v; &#125;);                  <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line">arr1.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">p, c, i</span>) </span>&#123; <span class="keyword">return</span> p + c + i; &#125;, <span class="string">''</span>); <span class="comment">// undefined011</span></span><br><span class="line">arr2.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">p, c, i</span>) </span>&#123; <span class="keyword">return</span> p + c + i; &#125;, <span class="string">''</span>); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>

<p>예제 arr1은 undefined와 1을 직접 할당한 반면 arr2는 빈 배열의 인덱스 1에 값 1을 할당했다. 이 두 배열은 배열의 각 요소를 순회하는 것을 기본으로 추가적인 기능을 수행하는 메서드들, 즉 forEach, map, filter, reduce 등에서 서로 다른 결과를 보인다. 사용자가 직접 undefined를 할당한 arr1에 대해서는 일반적으로 알고 있는 대로 배열의 모든 요소를 순회해서 결과를 출력한다. 그러나 arr2에 대한 결과를 보면, 각 메서드들이 비어 있는 요소에 대해서는 어떠한 처리도 하지 않고 건너뛰었음을 알 수 있다.</p>
<p>존재하지 않는 프로퍼티에 대해서는 순회할 수 없는 것이 당연하다. 배열은 무조건 length 프로퍼티의 개수만큼 빈 공간을 확보하고 각 공간에 인덱스를 이름으로 지정할 것이라고 생각하기 쉽지만, 실제로는 객체와 마찬가지로 특정 인덱스에 값을 지정할 때 비로소 빈 공간을 확보하고 인덱스를 이름으로 지정하고 데이터의 주솟값을 저장하는 등의 동작을 한다. 즉, 값이 지정되지 않은 인덱스는 ‘아직은 존재하지 않는 프로퍼티’에 지나지 않는 것이다.</p>
<p>값으로써 어딘가에 할당된 undefined는 실존하는 데이터인 반면, 자바스크립트 엔진이 반환해주는 undefined는 문자 그대로 값이 없음을 나타내는 것이다.</p>
<blockquote>
<p>보통 ‘var a’라는 구문에 의해 식별자 a에 자동으로 undefined&gt;가 ‘할당된다’고 알려져 있지만, 자바스크립트가 실제로 그렇게 동작하는 것은 아니다.<br>정확히는 아무것도 할당하지 않고 끝나며, 이후 변수 a에 접근하고자 할 때 비로소 undefined를 반환하는 것이 맞다.</p>
</blockquote>
<p>‘비어있음’을 명시적으로 나타내고 싶을 때는 undefined 대신 null을 쓰면 된다. null은 애초에 이런 용도로 만든 데이터 타입이다. 이런 규칙을 따르는 한 undefined는 오직 ‘값을 대입하지 않은 변수에 접근하고자 할 때 자바스크립트 엔진이 반환해주는 값’으로서만 존재할 수 있다.</p>
<p>추가로 null은 한 가지 주의할 점이 있다. 바로 typeof null이 object라는 점이다. 이는 자바스크립트 자체 버그이다.<del>(히익..)</del> 따라서 어떤 변수의 값이 null인지 여부를 판별하기 위해서는 typeof 대신 다른 방식으로 접근해야 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> n);        <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(n == <span class="literal">undefined</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(n == <span class="literal">null</span>);       <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(n === <span class="literal">undefined</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(n === <span class="literal">null</span>);      <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>4번째 줄과 같이 동등 연산자(==)로 비교할 경우 null과 undefined가 서로 같다고 판단한다. 따라서 어떤 변수가 실제로 null인지 아니면 undefined인지는 동등 연산자로 비교해서는 알 수 없다. 7번째 8번째 줄과 같이 일치 연산자(===)를 써야만 정확히 판별할 수 있다.</p>
<p>참고 : <a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId>=206513031" target="_blank" rel="noopener">코어 자바스크립트</a></p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">태그</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/Javascript/">Javascript</a> <a class="tag tag--primary tag--small t-link" href="/tags/데이터-타입/">데이터 타입</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a
                        class="post-action-btn btn btn--disabled"
                        aria-hidden="true"
                    >
                        
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/02/02/Javascript-데이터-타입/"
                    data-tooltip="[Javascript] 데이터 타입 (1)"
                    aria-label="다음: [Javascript] 데이터 타입 (1)"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cok2exe.github.io/2020/02/09/Javascript-데이터-타입-2/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cok2exe.github.io/2020/02/09/Javascript-데이터-타입-2/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://cok2exe.github.io/2020/02/09/Javascript-데이터-타입-2/"
                    title="Google+에 공유하기"
                    aria-label="Google+에 공유하기"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 dajyu. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a
                        class="post-action-btn btn btn--disabled"
                        aria-hidden="true"
                    >
                        
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/02/02/Javascript-데이터-타입/"
                    data-tooltip="[Javascript] 데이터 타입 (1)"
                    aria-label="다음: [Javascript] 데이터 타입 (1)"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cok2exe.github.io/2020/02/09/Javascript-데이터-타입-2/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cok2exe.github.io/2020/02/09/Javascript-데이터-타입-2/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://cok2exe.github.io/2020/02/09/Javascript-데이터-타입-2/"
                    title="Google+에 공유하기"
                    aria-label="Google+에 공유하기"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://cok2exe.github.io/2020/02/09/Javascript-데이터-타입-2/"
                        aria-label="Facebook에 공유하기"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Facebook에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://cok2exe.github.io/2020/02/09/Javascript-데이터-타입-2/"
                        aria-label="Twitter에 공유하기"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Twitter에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=https://cok2exe.github.io/2020/02/09/Javascript-데이터-타입-2/"
                        aria-label="Google+에 공유하기"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Google+에 공유하기</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/cat.jpeg" alt="저자 이미지"/>
        
            <h4 id="about-card-name">dajyu</h4>
        
            <div id="about-card-bio"><p>혼잣말 공부러(코드사냥꾼)</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Web frontend</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Asia/Seoul
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->


    




    </body>
</html>
