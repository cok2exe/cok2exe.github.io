
<!DOCTYPE html>
<html lang="ko">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="공부방">
    <title>[Javascript] this - 공부방</title>
    <meta name="author" content="dajyu">
    
        <meta name="keywords" content="React,Typescript,HTML,CSS,Frontend,">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"dajyu","sameAs":["https://github.com/cok2exe","http://stackoverflow.com/cok2exe"],"image":"over.jpg"},"articleBody":"자바스크립트에서 가장 혼란스러운 개념은 꼽으라면 this일 것이다. 다른 대부분의 객체지향 언어에서 this는 클래스로 생성한 인스터스 객체를 의미한다. 클래스에서만 사용할 수 있기 때문에 혼란의 여지가 없거나 많지 않다. 그러나 자바스크립트에서의 this는 어디서든 사용할 수 있다. 상황에 따라 this가 바라보는 대상이 달라지는데, 어떤 이유로 그렇게 되는지를 파악하기 힘든 경우도 있고 예상과 다르게 엉뚱한 대상을 바라보는 경우도 있다.\n\n함수와 객체(메서드)의 구분이 느슨한 자바스크립트에서 this는 실질적으로 이 둘을 구분하는 거의 유일한 기능이다.\n\n\n\n1. 상황에 따라 달라지는 this자바스크립트에서 this는 기본적으로 실행 컨텍스트(함수가 생성될 때 호출됨)가 생성될 때 함께 결정된다. 즉, this는 함수를 호출할 때 결정된다고 할 수 있다. 함수를 어떤 방식으로 호출하느냐에 따라 값이 달라지는 것이다.\n1-1. 전역 공간에서의 this전역 공간에서 this는 전역 객체를 가리킨다. 개념상 전역 컨텍스트를 생성하는 주체가 바로 전역 객체이기 때문이다. 전역 객체는 자바스크립트 런타임 환경에 따라 다른 이름과 정보를 가지고 있다. 브라우저 환경에서 전역객체는 window이고 Node.js 환경에서는 global이다.\n\n전역 공간에서만 발생하는 특이한 성질이 있다. 전역변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티로 할당한다.전역변수 선언과 전역객체의 프로퍼티 할당 사이에 전혀 다른 경우도 있다. 바로 ‘삭제’ 명령에 대해 그렇다.\n\n123var a = 1;delete window.a;console.log(a, window.a, this.a); // 1 1 1\n\n123var b = 2;delete b;console.log(b, window.b, this.b); // 2 2 2\n\n123window.c = 3;delete window.c;console.log(c, window.c, this.c); // Uncaught ReferenceError: c is not defined\n\n123window.d = 4;delete d;console.log(d, window.d, this.d); // 4 4 4\n\n처음부터 전역객체의 프로퍼티로 할당한 경우에는 삭제가 되는 반면 전역변수로 선언한 경우에는 삭제가 되는 반면 전역변수로 선언한 경우에는 삭제가 되지 않는다. 이는 사용자가 의도치 않게 삭제하는 것을 방지하는 차원에서 마련한 나름의 방어 전략이라고 해석된다.\n1-2. 메서드로 호출할 때 그 메서드 내부에서의 this함수 vs 메서드\n어떤 함수를 실행하는 방법은 여러 가지가 있는데, 가장 일반적인 방법 두 가지는 함수로서 호출하는 경우와 메서드로서 호출하는 경우이다. 함수와 메서드는 미리 정의한 동작을 수행하는 코드 뭉치로, 이 둘을 구분하는 유일한 차이는 독립성에 있다. 함수는 그 자체로 독립적인 기능을 수행하는 반면, 메서드는 자신을 호출한 대상 객체에 관한 동작을 수행한다. 자바스크립트는 상황별로 this 키워드에 다른 값을 부여하게 함으로써 이를 구현했다.\n어떤 함수를 객체의 프로퍼티에 할당한다고 해서 그 자체로서 무조건 메서드가 되는 것이 아니라 객체의 메서드로서 호출할 경우에만 메서드로 동작하고, 그렇지 않으면 함수로 동작한다.\n[예제 6 함수로서 호출, 메서드로서 호출]\n123456789var func = function(x) &#123;  console.log(this, x);&#125;;func(1); // window &#123; ... &#125; 1var obj = &#123;  method: func&#125;;obj.method(2); // &#123; method: f &#125; 2\n\n1번째 줄에서 func라는 변수에 익명함수를 할당했다. 4번째 줄에서 func를 호출했더니 this로 전역객체 window가 출력된다. 6번째 줄에서 obj라는 변수에 객체를 할당하는데, 그 객체의 method 프로퍼티에 앞에서 만든 func 함수를 할당했다. 이제 9번째 줄에서 obj의 method를 호출했더니, 이번에는 this가 obj라고 한다. obj의 프로퍼티에 할당한 값과 func 변수에 할당한 값은 모두 1번째 줄에서 선언한 함수를 참조한다. 즉 원래의 익명함수는 그대로인데 이를 변수에 담아 호출한 경우와 obj 객체의 프로퍼티에 할당해서 호출한 경우에 this가 달라지는 것이다.\n그렇다면 ‘함수로서 호출’과 ‘메서드로서 호출’을 어떻게 구분할까? 함수 앞에 점(.)이 있는지 여부만으로 간단하게 구분할 수 있다. 예제 6의 4번째 줄은 앞에 점이 없으니 함수로서 호출한 것이고, 9번째 줄은 method 앞에 점이 있으니 메서드로서 호출한 것이다. 정말이다!!(물론 대괄호 표기법에 따른 경우에도 메서드로 호출한 것이다.)\n[예제 7 메서드로서 호출 - 점 표기법, 대괄호 표기법]\n1234567var obj = &#123;  method: function(x) &#123;    console.log(this, x);  &#125;&#125;;obj.method(1); // &#123; method: f &#125; 1obj[\"method\"](2); // &#123; method: f &#125; 2\n\n다시 말해 점 표기법이든 대괄호 표기법이든, 어떤 함수를 호출할 때 그 함수 이름(프로퍼티명) 앞에 객체가 명시돼 있는 경우에는 메서드로 호출한 것이고, 그렇지 않은 모든 경우에는 함수로 호출한 것이다.\n메서드 내부에서의 this\nthis에는 호출한 주체에 대한 정보가 담긴다. 어떤 함수를 메서드로서 호출하는 경우 호출 주체는 바로 함수명(프로퍼티명) 앞의 객체이다. 점 표기법의 경우 마지막 점 앞에 명시된 객체가 곧 this가 되는 것이다.\n[예제 8 메서드 내부에서의 this]\n1234567891011121314151617var obj = &#123;  methodA: function() &#123;    console.log(this);  &#125;,  inner: &#123;    methodB: function() &#123;      console.log(this);    &#125;  &#125;&#125;;obj.methodA(); // &#123; methodA: f, inner: &#123; ... &#125; &#125; (===obj)obj[\"methodA\"](); // &#123; methodA: f, inner: &#123; ... &#125; &#125; (===obj)obj.inner.methodB(); // &#123; methodB: f &#125; (===obj.inner)obj.inner[\"methodB\"](); // &#123; methodB: f &#125; (===obj.inner)obj[\"inner\"].methodB(); // &#123; methodB: f &#125; (===obj.inner)obj[\"inner\"][\"methodB\"](); // &#123; methodB: f &#125; (===obj.inner)\n\n1-3. 함수로서 호출할 때 그 함수 내부에서의 this함수 내부에서의 this\n어떤 함수를 함수로서 호출할 경우에는 this가 지정되지 않는다. this에는 호출한 주체에 대한 정보가 담긴다고 했는데, 함수로서 호출하는 것은 호출 주체(객체지향 언어에서의 객체)를 명시하지 않고 개발자가 코드에 직접 관여해서 실행한 것이기 때문에 호출 주체의 정보를 알 수 없는 것이다. 실행 컨텍스트를 활성화할 당시에 this가 지정되지 않은 경우 this는 전역 객체를 바라본다. 따라서 함수에서의 this는 전역 객체를 가리킨다. 더글라스 크락포드는 이를 명백한 설계상의 오류라고 지적한다. 그 이유는 바로 이어서 설명한다.\n메서드 내부함수에서의 this\n메서드 내부에서 정의하고 실행한 함수에서의 this는 자바스크립트 초심자들이 this에 관해 가장 자주 혼란을 느끼는 지점 중 하나이다. 앞서 소개한 ‘설계상의 오류’로 인해 실제 동작과 다르게 예측하곤 한다. this라는 단어 자체가 주는 느낌적 느낌 그대로 코드를 바라보면 예상과 다른 결과가 나온다.\n123456789101112131415var obj1 = &#123;  outer: function() &#123;    console.log(this); // (1)    var innerFunc = function() &#123;      console.log(this); // (2) (3)    &#125;;    innerFunc();    var obj2 = &#123;      innerMethod: innerFunc    &#125;;    obj2.innerMethod();  &#125;&#125;;obj1.outer();\n\n정답은 (1): obj1, (2): 전역객체(window), (3): obj2.innerMethod이다.\n\n1번째 줄: 객체를 생성. 이때 객체 내부에는 outer라는 프로퍼티가 있으며, 여기에는 익명함수가 연결된다. 이렇게 생성한 객체를 변수 obj1에 할당한다.\n15번째 줄: obj1.outer를 호출한다.\n2번째 줄: obj1.oter 함수의 실행 컨텍스트가 생성되면서 호이스팅하고, 스코프 체인 정보를 수집하고, this를 바인딩. 이 함수는 호출할 때 함수명인 outer 앞에 점(.)이 있으므로 메서드로서 호출한 것. 따라서 this는 마지막 점 앞의 객체인 obj1이 바인딩.\n3번째 줄: obj1 객체 정보가 출력된다.\n4번째 줄: 호이스팅된 변수 innerFunc는 outer 스코프 내에서만 접근할 수 있는 지역변수이다. 이 지역변수에 익명 함수를 할당한다.\n7번째 줄: innerFunc를 호출한다.\n4번째 줄: innerFunc 함수의 실행 컨텍스트가 생성되면서 호이스팅, 스코프 체인 수집, this 바인딩 등을 수행. 이 함수를 호출할 때 함수명 앞에는 점(.)이 없었다. 즉 함수로서 호출한 것이므로 this가 지정되지 않았고, 따라서 자동으로 스코프 체인상의 최상위 객체인 전역객체(window)가 바인딩.\n5번째 줄: window 객체 정보가 출력\n9번째 줄: 호이스팅된 변수 obj2 역시 outer 스코프 내에서만 접근할 수 있는 지역변수이다. 여기에는 다시 객체를 할당하는데, 그 객체에는 innerMethod라는 프로퍼티가 있으며, 여기에는 앞서 정의된 변수 innerFunc와 연결된 익명 함수가 연결된다.\n12번째 줄: obj2.innerMethod를 호출\n9번째 줄: obj2.innerMethod 함수의 실행 컨텍스트가 생성됨. 이 함수는 호출할 때 함수명인 innerMethod 앞에 점(.)이 있었으므로 메서드로서 호출한 것. 따라서 this에는 마지막 점 앞의 객체인 obj2가 바인딩.\n10번째 줄: obj2 객체 정보 출력\n\n7번째 줄에서는 outer 메서드 내부에 있는 함수(innerFunc)를 함수로서 호출했다. 반면 12번째 줄에서는 같은 함수(innerFunc)를 메서드로서 호출했다. 같은 함수임에도 7번째 줄에 의해 바인딩되는 this와 12번째 줄에 의해 바인딩되는 this의 대상이 서로 달라진 것이다.\n그러니까 this 바인딩에 관해서는 함수를 실행하는 당시의 주변 환경(메서드 내부인지, 함수 내부인지 등)은 중요하지 않고, 오직 해당 함수를 호출하는 구문 앞에 점 또는 대괄호 표기가 있는지 없는지가 관건인 것이다.\n메서드의 내부 함수에서의 this를 우회하는 방법\n이렇게 하면 this에 대한 구분은 명확히 할 수 있지만, 그 결과 this라는 단어가 주는 인상과는 사뭇 달라져 버렸다. 호출 주체가 없을 때는 자동으로 전역객체를 바인딩하지 않고 호출 당시 주변 환경의 this를 그대로 상속받아 사용할 수 있다면 좋겠다. 그게 훨씬 자연스러울뿐더러 자바스크립트 설계상 이렇게 동작하는 편이 스코프 체인과의 일관성을 지키는 설득력 있는 방식이었다. 변수를 검새갛면 우선 가장 가까운 스코프의 L.E(LexicalEnvironment)를 찾고 없으면 상위 스코프를 탐색하듯이, this 역시 현재 컨텍스트에 바인딩된 대상이 없으면 직전 컨텍스트의 this를 바라보도록 말이다.\n아쉽게도 ES5까지는 자체적으로 내부함수에 this를 상속할 방법이 없지만 다행히 이를 우회할 방법이 없지는 않다. 그중 대표적인 방법은 바로 변수를 활용하는 것이다.\n[예제 10 내부함수에서의 this를 우회하는 방법]\n123456789101112131415var obj = &#123;  outer: function() &#123;    var innerFunc1 = function() &#123;      console.log(this);    &#125;;    innerFunc1();    var self = this;    var innerFunc2 = function() &#123;      console.log(self);    &#125;;    innerFunc2();  &#125;&#125;;obj.outer();\n\n위 예제의 innerFunc1 내부에서 this는 전역객체를 가리킨다. 한편 outer 스코프에서 self라는 변수에 this를 저장한 상태에서 호출한 innerFunc2의 경우 self에는 객체 obj가 출력된다.\nthis를 바인딩하지 않는 함수\nES6에서는 함수 내부에서 this가 전역객체를 바라보는 문제를 보완하고자, this를 바인딩하지 않는 화살표 함수를 새로 도입했다. 화살표 함수는 실행 컨텍스트를 생성할 때 this 바인딩 과정 자체가 빠지게 되어, 상위 스코프의 this를 그대로 활용할 수 있다. 내부함수를 화살표 함수로 바꾸면 ‘우회법’이 불필요해진다.\n[예제 11 this를 바인딩하지 않는 함수(화살표 함수)]\n12345678910var obj = &#123;  outer: function() &#123;    console.log(this); // (1) &#123; outer: f &#125;    var innerFunc = () =&gt; &#123;      console.log(this); // (2) &#123; outer: f &#125;    &#125;;    innerFunc();  &#125;&#125;;obj.outer();\n\n그 밖에도 call, apply 등의 메서드를 활용해 함수를 호출할 때 명시적으로 this를 지정하는 방법이 있다.\n1-4. 콜백 함수 호출 시 그 함수 내부에서의 this콜백 함수의 정의와 동작 원리 등에 대해서는 바로 다음장에서 자세히 다룬다. 여기서는 this가 어떤 값을 참조하는지만 간단히 확인하고 넘어간다.\n함수 A의 제어권을 다른 함수(또는 메서드) B에게 넘겨주는 경우 함수 A를 콜백 함수라 한다. 이때 함수 A는 함수 B의 내부 로직에 따라 실행되며, this 역시 함수 B 내부 로직에서 정한 규칙에 따라 값이 결정된다. 콜백 함수도 함수이기 때문에 기본적으로 1-3 절에서와 마찬가지로 this가 전역객체를 참조하지만, 제어권을 받은 함수에서 콜백 함수에 별도로 this가 될 대상을 지정한 경우에는 그 대상을 참조하게 된다.\n[예제 12 콜백 함수 내부에서의 this]\n12345678910111213setTimeout(function() &#123;  console.log(this);&#125;, 300); // (1)[1, 2, 3, 4, 5].forEach(function(x) &#123;  // (2)  console.log(this, x);&#125;);document.body.innerHTML += '&lt;button id=\"a\"&gt;클릭&lt;/button&gt;';document.body.querySelector(\"#a\").addEventListener(\"click\", function(e) &#123;  console.log(this, e); // (3)&#125;);\n\n(1): setTimeout 함수는 300ms 만큼 시간 지연을 한 뒤 콜백 함수를 실행하라는 명령이다. 0.3초 뒤 전역객체가 출력된다.\n(2): forEach 메서드는 배열의 각 요소를 앞에서부터 차례로 하나씩 꺼내어 그 값을 콜백 함수의 첫 번째 인자로 삼아 함수를 실행하라는 명령이다. 전역객체와 배열의 각 요소가 총 5회 출력된다.\n(3): addEventListener는 지정한 HTML 엘리먼트에 ‘click’ 이벤트가 발생할 때마다 그 이벤트 정보를 콜백 함수의 첫 번째 인자로 삼아 함수를 실행하라는 명령이다. 버튼을 클릭하면 앞서 지정한 엘리먼트와 클릭 이벤트에 관한 정보가 담긴 객체가 출력된다.\n(1)의 setTimeout 함수와 (2)의 forEach 메서드는 그 내부에서 콜백 함수를 호출할 때 대상이 될 this를 지정하지 않는다. 따라서 콜백 함수 내부에서의 this는 전역객체를 참조한다. 반면 (3)의 addEventListener 메서드는 콜백 함수를 호출할 때 자신의 this를 상속하도록 정의돼 있다. 그러니까 메서드명의 점(.) 앞부분이 곧 this가 되는 것이다.\n이처럼 콜백 함수에서의 this는 ‘무조건 이거다’라고 정의할 수 없다. 콜백 함수의 제어권을 가지는 함수(메서드)가 콜백 함수에서의 this를 무엇으로 할지를 결정하며, 특별히 정의하지 않은 경우에는 기본적으로 함수와 마찬가지로 전역객체를 바라본다.\n1-5. 생성자 함수 내부에서의 this생성자 함수는 어떤 공통된 성질을 지니는 객체들을 생성하는 데 사용하는 함수이다. 객체지향 언어에서는 생성자를 클래스, 클래스를 통해 만든 객체를 인스턴스라 한다.\n프로그래밍적으로 ‘생성자’는 구체적인 인스턴스를 만들기 위한 일종의 틀이다. 이 틀에는 해당 클래스의 공통 속성들이 미리 준비돼 있고, 여기에 구체적인 인스턴스의 개성을 더해 개별 인스턴스를 만들 수 있는 것이다.\n자바스크립트는 함수에 생성자로서의 역할을 함께 부여했다. new 명령어와 함께 함수를 호출하면 해당 함수가 생성자로서 동작하게 된다. 그리고 어떤 함수가 생성자 함수로서 호출된 경우 내부에서의 this는 곧 새로 만들 구체적인 인스턴스 자신이 된다.\n생성자 함수를 호출(new 명령어와 함께 호출)하면 우선 생성자의 prototype 프로퍼티를 참조하는 __proto__라는 프로퍼티가 있는 객체(인스턴스)를 만들고, 미리 준비된 공통 속성 및 개성을 해당 객체(this)에 부여한다. 이렇게 해서 구체적인 인스턴스가 만들어진다.\n12345678910111213var Cat = function(name, age) &#123;  this.bark = \"야옹\";  this.name = name;  thia.age = age;&#125;;var choco = new Cat(\"초코\", 7);var nabi = new Cat(\"나비\", 5);console.log(choco, nabi);/* 결과Cat &#123; bark: '야옹', name: '초코', age: 7 &#125;Cat &#123; bark: '야옹', name: '나비', age: 5 &#125;*/\n\nCat이란 변수에 익명 함수를 할당했다. 이 함수 내부에서는 this에 접근해서 bark, name, age 프로퍼티에 각각 값을 대입한다. 6번째와 7번째 줄에서는 new 명령어와 함께 Cat 함수를 호출해서 변수 choco, nabi에 각각 할당했다. 8번째 줄에서는 choco와 nabi를 출력해보니 각각 Cat 클래스의 인스턴스 객체가 출력된다. 즉 6번째 줄에서 실행한 생성자 함수 내부에서의 this는 choco 인스턴스를, 7번째 줄에서 실행한 생성자 함수 내부에서의 this는 nabi 인스턴스를 가리킴을 알 수 있다.\n출처 : 코어 자바스크립트\n","dateCreated":"2020-03-01T09:46:12+09:00","dateModified":"2020-03-01T11:56:18+09:00","datePublished":"2020-03-01T09:46:12+09:00","description":"자바스크립트에서 가장 혼란스러운 개념은 꼽으라면 this일 것이다. 다른 대부분의 객체지향 언어에서 this는 클래스로 생성한 인스터스 객체를 의미한다. 클래스에서만 사용할 수 있기 때문에 혼란의 여지가 없거나 많지 않다. 그러나 자바스크립트에서의 this는 어디서든 사용할 수 있다. 상황에 따라 this가 바라보는 대상이 달라지는데, 어떤 이유로 그렇게 되는지를 파악하기 힘든 경우도 있고 예상과 다르게 엉뚱한 대상을 바라보는 경우도 있다.\n\n함수와 객체(메서드)의 구분이 느슨한 자바스크립트에서 this는 실질적으로 이 둘을 구분하는 거의 유일한 기능이다.\n","headline":"[Javascript] this","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://cok2exe.github.io/2020/03/01/Javascript-this/"},"publisher":{"@type":"Organization","name":"dajyu","sameAs":["https://github.com/cok2exe","http://stackoverflow.com/cok2exe"],"image":"over.jpg","logo":{"@type":"ImageObject","url":"over.jpg"}},"url":"https://cok2exe.github.io/2020/03/01/Javascript-this/","keywords":"Javascript, this"}</script>
    <meta name="description" content="자바스크립트에서 가장 혼란스러운 개념은 꼽으라면 this일 것이다. 다른 대부분의 객체지향 언어에서 this는 클래스로 생성한 인스터스 객체를 의미한다. 클래스에서만 사용할 수 있기 때문에 혼란의 여지가 없거나 많지 않다. 그러나 자바스크립트에서의 this는 어디서든 사용할 수 있다. 상황에 따라 this가 바라보는 대상이 달라지는데, 어떤 이유로 그렇게">
<meta name="keywords" content="Javascript,this">
<meta property="og:type" content="blog">
<meta property="og:title" content="[Javascript] this">
<meta property="og:url" content="https://cok2exe.github.io/2020/03/01/Javascript-this/index.html">
<meta property="og:site_name" content="공부방">
<meta property="og:description" content="자바스크립트에서 가장 혼란스러운 개념은 꼽으라면 this일 것이다. 다른 대부분의 객체지향 언어에서 this는 클래스로 생성한 인스터스 객체를 의미한다. 클래스에서만 사용할 수 있기 때문에 혼란의 여지가 없거나 많지 않다. 그러나 자바스크립트에서의 this는 어디서든 사용할 수 있다. 상황에 따라 this가 바라보는 대상이 달라지는데, 어떤 이유로 그렇게">
<meta property="og:locale" content="ko">
<meta property="og:updated_time" content="2020-03-01T02:56:18.648Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[Javascript] this">
<meta name="twitter:description" content="자바스크립트에서 가장 혼란스러운 개념은 꼽으라면 this일 것이다. 다른 대부분의 객체지향 언어에서 this는 클래스로 생성한 인스터스 객체를 의미한다. 클래스에서만 사용할 수 있기 때문에 혼란의 여지가 없거나 많지 않다. 그러나 자바스크립트에서의 this는 어디서든 사용할 수 있다. 상황에 따라 this가 바라보는 대상이 달라지는데, 어떤 이유로 그렇게">
    
    
        
    
    
        <meta property="og:image" content="https://cok2exe.github.io/assets/images/over.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            공부방
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="링크 열기: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/over.jpg" alt="저자 이미지"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="저자에 대해 더 알아보기"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/over.jpg" alt="저자 이미지"/>
                </a>
                <h4 class="sidebar-profile-name">dajyu</h4>
                
                    <h5 class="sidebar-profile-bio"><p>혼잣말 공부러(코드사냥꾼)</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="Home"
                        >
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                            title="About"
                        >
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/cok2exe" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="http://stackoverflow.com/cok2exe" target="_blank" rel="noopener" title="Stack Overflow">
                    
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            [Javascript] this
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2020-03-01T09:46:12+09:00">
	
		    2020/03/01
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/Javascript/">Javascript</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>자바스크립트에서 가장 혼란스러운 개념은 꼽으라면 <code>this</code>일 것이다. 다른 대부분의 객체지향 언어에서 <code>this</code>는 클래스로 생성한 인스터스 객체를 의미한다. 클래스에서만 사용할 수 있기 때문에 혼란의 여지가 없거나 많지 않다. 그러나 자바스크립트에서의 <code>this</code>는 어디서든 사용할 수 있다. 상황에 따라 <code>this</code>가 바라보는 대상이 달라지는데, 어떤 이유로 그렇게 되는지를 파악하기 힘든 경우도 있고 예상과 다르게 엉뚱한 대상을 바라보는 경우도 있다.</p>
<blockquote>
<p>함수와 객체(메서드)의 구분이 느슨한 자바스크립트에서 <code>this</code>는 실질적으로 이 둘을 구분하는 거의 유일한 기능이다.</p>
</blockquote>
<a id="more"></a>

<h3 id="1-상황에-따라-달라지는-this"><a href="#1-상황에-따라-달라지는-this" class="headerlink" title="1. 상황에 따라 달라지는 this"></a>1. 상황에 따라 달라지는 this</h3><p>자바스크립트에서 <code>this</code>는 기본적으로 실행 컨텍스트(함수가 생성될 때 호출됨)가 생성될 때 함께 결정된다. 즉, <code>this</code>는 <strong>함수를 호출할 때 결정된다</strong>고 할 수 있다. 함수를 어떤 방식으로 호출하느냐에 따라 값이 달라지는 것이다.</p>
<h4 id="1-1-전역-공간에서의-this"><a href="#1-1-전역-공간에서의-this" class="headerlink" title="1-1. 전역 공간에서의 this"></a>1-1. 전역 공간에서의 this</h4><p>전역 공간에서 <code>this</code>는 전역 객체를 가리킨다. 개념상 전역 컨텍스트를 생성하는 주체가 바로 전역 객체이기 때문이다. 전역 객체는 자바스크립트 런타임 환경에 따라 다른 이름과 정보를 가지고 있다. 브라우저 환경에서 전역객체는 window이고 Node.js 환경에서는 global이다.</p>
<blockquote>
<p>전역 공간에서만 발생하는 특이한 성질이 있다. 전역변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티로 할당한다.<br>전역변수 선언과 전역객체의 프로퍼티 할당 사이에 전혀 다른 경우도 있다. 바로 ‘삭제’ 명령에 대해 그렇다.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.a;</span><br><span class="line"><span class="built_in">console</span>.log(a, <span class="built_in">window</span>.a, <span class="keyword">this</span>.a); <span class="comment">// 1 1 1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">delete</span> b;</span><br><span class="line"><span class="built_in">console</span>.log(b, <span class="built_in">window</span>.b, <span class="keyword">this</span>.b); <span class="comment">// 2 2 2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.c = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.c;</span><br><span class="line"><span class="built_in">console</span>.log(c, <span class="built_in">window</span>.c, <span class="keyword">this</span>.c); <span class="comment">// Uncaught ReferenceError: c is not defined</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.d = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">delete</span> d;</span><br><span class="line"><span class="built_in">console</span>.log(d, <span class="built_in">window</span>.d, <span class="keyword">this</span>.d); <span class="comment">// 4 4 4</span></span><br></pre></td></tr></table></figure>

<p>처음부터 전역객체의 프로퍼티로 할당한 경우에는 삭제가 되는 반면 전역변수로 선언한 경우에는 삭제가 되는 반면 전역변수로 선언한 경우에는 삭제가 되지 않는다. 이는 사용자가 의도치 않게 삭제하는 것을 방지하는 차원에서 마련한 나름의 방어 전략이라고 해석된다.</p>
<h4 id="1-2-메서드로-호출할-때-그-메서드-내부에서의-this"><a href="#1-2-메서드로-호출할-때-그-메서드-내부에서의-this" class="headerlink" title="1-2. 메서드로 호출할 때 그 메서드 내부에서의 this"></a>1-2. 메서드로 호출할 때 그 메서드 내부에서의 this</h4><p><strong>함수 vs 메서드</strong></p>
<p>어떤 함수를 실행하는 방법은 여러 가지가 있는데, 가장 일반적인 방법 두 가지는 함수로서 호출하는 경우와 메서드로서 호출하는 경우이다. 함수와 메서드는 미리 정의한 동작을 수행하는 코드 뭉치로, 이 둘을 구분하는 유일한 차이는 <strong>독립성</strong>에 있다. 함수는 그 자체로 독립적인 기능을 수행하는 반면, 메서드는 자신을 호출한 대상 객체에 관한 동작을 수행한다. 자바스크립트는 상황별로 <code>this</code> 키워드에 다른 값을 부여하게 함으로써 이를 구현했다.</p>
<p>어떤 함수를 객체의 프로퍼티에 할당한다고 해서 그 자체로서 무조건 메서드가 되는 것이 아니라 객체의 메서드로서 호출할 경우에만 메서드로 동작하고, 그렇지 않으면 함수로 동작한다.</p>
<p>[예제 6 함수로서 호출, 메서드로서 호출]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>, x);</span><br><span class="line">&#125;;</span><br><span class="line">func(<span class="number">1</span>); <span class="comment">// window &#123; ... &#125; 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  method: func</span><br><span class="line">&#125;;</span><br><span class="line">obj.method(<span class="number">2</span>); <span class="comment">// &#123; method: f &#125; 2</span></span><br></pre></td></tr></table></figure>

<p>1번째 줄에서 func라는 변수에 익명함수를 할당했다. 4번째 줄에서 func를 호출했더니 <code>this</code>로 전역객체 window가 출력된다. 6번째 줄에서 obj라는 변수에 객체를 할당하는데, 그 객체의 method 프로퍼티에 앞에서 만든 func 함수를 할당했다. 이제 9번째 줄에서 obj의 method를 호출했더니, 이번에는 <code>this</code>가 obj라고 한다. obj의 프로퍼티에 할당한 값과 func 변수에 할당한 값은 모두 1번째 줄에서 선언한 함수를 참조한다. 즉 원래의 익명함수는 그대로인데 이를 변수에 담아 호출한 경우와 obj 객체의 프로퍼티에 할당해서 호출한 경우에 <code>this</code>가 달라지는 것이다.</p>
<p>그렇다면 ‘함수로서 호출’과 ‘메서드로서 호출’을 어떻게 구분할까? 함수 앞에 점(.)이 있는지 여부만으로 간단하게 구분할 수 있다. 예제 6의 4번째 줄은 앞에 점이 없으니 함수로서 호출한 것이고, 9번째 줄은 method 앞에 점이 있으니 메서드로서 호출한 것이다. 정말이다!!(물론 대괄호 표기법에 따른 경우에도 메서드로 호출한 것이다.)</p>
<p>[예제 7 메서드로서 호출 - 점 표기법, 대괄호 표기법]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>, x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.method(<span class="number">1</span>); <span class="comment">// &#123; method: f &#125; 1</span></span><br><span class="line">obj[<span class="string">"method"</span>](<span class="number">2</span>); <span class="comment">// &#123; method: f &#125; 2</span></span><br></pre></td></tr></table></figure>

<p>다시 말해 점 표기법이든 대괄호 표기법이든, 어떤 함수를 호출할 때 그 함수 이름(프로퍼티명) 앞에 객체가 명시돼 있는 경우에는 메서드로 호출한 것이고, 그렇지 않은 모든 경우에는 함수로 호출한 것이다.</p>
<p><strong>메서드 내부에서의 this</strong></p>
<p><code>this</code>에는 호출한 주체에 대한 정보가 담긴다. 어떤 함수를 메서드로서 호출하는 경우 호출 주체는 바로 함수명(프로퍼티명) 앞의 객체이다. 점 표기법의 경우 <u>마지막 점 앞에 명시된 객체</u>가 곧 <code>this</code>가 되는 것이다.</p>
<p>[예제 8 메서드 내부에서의 this]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  methodA: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  inner: &#123;</span><br><span class="line">    methodB: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.methodA(); <span class="comment">// &#123; methodA: f, inner: &#123; ... &#125; &#125; (===obj)</span></span><br><span class="line">obj[<span class="string">"methodA"</span>](); <span class="comment">// &#123; methodA: f, inner: &#123; ... &#125; &#125; (===obj)</span></span><br><span class="line"></span><br><span class="line">obj.inner.methodB(); <span class="comment">// &#123; methodB: f &#125; (===obj.inner)</span></span><br><span class="line">obj.inner[<span class="string">"methodB"</span>](); <span class="comment">// &#123; methodB: f &#125; (===obj.inner)</span></span><br><span class="line">obj[<span class="string">"inner"</span>].methodB(); <span class="comment">// &#123; methodB: f &#125; (===obj.inner)</span></span><br><span class="line">obj[<span class="string">"inner"</span>][<span class="string">"methodB"</span>](); <span class="comment">// &#123; methodB: f &#125; (===obj.inner)</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-함수로서-호출할-때-그-함수-내부에서의-this"><a href="#1-3-함수로서-호출할-때-그-함수-내부에서의-this" class="headerlink" title="1-3. 함수로서 호출할 때 그 함수 내부에서의 this"></a>1-3. 함수로서 호출할 때 그 함수 내부에서의 this</h4><p><strong>함수 내부에서의 this</strong></p>
<p>어떤 함수를 함수로서 호출할 경우에는 <code>this</code>가 지정되지 않는다. <code>this</code>에는 호출한 주체에 대한 정보가 담긴다고 했는데, 함수로서 호출하는 것은 호출 주체(객체지향 언어에서의 객체)를 명시하지 않고 개발자가 코드에 직접 관여해서 실행한 것이기 때문에 호출 주체의 정보를 알 수 없는 것이다. 실행 컨텍스트를 활성화할 당시에 <code>this</code>가 지정되지 않은 경우 <code>this</code>는 전역 객체를 바라본다. 따라서 함수에서의 <code>this</code>는 전역 객체를 가리킨다. <a href="https://g.co/kgs/cisA2g" target="_blank" rel="noopener">더글라스 크락포드</a>는 이를 명백한 설계상의 오류라고 지적한다. 그 이유는 바로 이어서 설명한다.</p>
<p><strong>메서드 내부함수에서의 this</strong></p>
<p>메서드 내부에서 정의하고 실행한 함수에서의 <code>this</code>는 자바스크립트 초심자들이 <code>this</code>에 관해 가장 자주 혼란을 느끼는 지점 중 하나이다. 앞서 소개한 ‘설계상의 오류’로 인해 실제 동작과 다르게 예측하곤 한다. <code>this</code>라는 단어 자체가 주는 느낌적 느낌 그대로 코드를 바라보면 예상과 다른 결과가 나온다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  outer: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">var</span> innerFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// (2) (3)</span></span><br><span class="line">    &#125;;</span><br><span class="line">    innerFunc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">      innerMethod: innerFunc</span><br><span class="line">    &#125;;</span><br><span class="line">    obj2.innerMethod();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj1.outer();</span><br></pre></td></tr></table></figure>

<p>정답은 (1): obj1, (2): 전역객체(window), (3): obj2.innerMethod이다.</p>
<ul>
<li>1번째 줄: 객체를 생성. 이때 객체 내부에는 outer라는 프로퍼티가 있으며, 여기에는 익명함수가 연결된다. 이렇게 생성한 객체를 변수 obj1에 할당한다.</li>
<li>15번째 줄: obj1.outer를 호출한다.</li>
<li>2번째 줄: obj1.oter 함수의 실행 컨텍스트가 생성되면서 호이스팅하고, 스코프 체인 정보를 수집하고, this를 바인딩. 이 함수는 호출할 때 함수명인 outer 앞에 점(.)이 있으므로 메서드로서 호출한 것. 따라서 <code>this</code>는 마지막 점 앞의 객체인 obj1이 바인딩.</li>
<li>3번째 줄: obj1 객체 정보가 출력된다.</li>
<li>4번째 줄: 호이스팅된 변수 innerFunc는 outer 스코프 내에서만 접근할 수 있는 지역변수이다. 이 지역변수에 익명 함수를 할당한다.</li>
<li>7번째 줄: innerFunc를 호출한다.</li>
<li>4번째 줄: innerFunc 함수의 실행 컨텍스트가 생성되면서 호이스팅, 스코프 체인 수집, this 바인딩 등을 수행. 이 함수를 호출할 때 함수명 앞에는 점(.)이 없었다. 즉 함수로서 호출한 것이므로 <code>this</code>가 지정되지 않았고, 따라서 자동으로 스코프 체인상의 최상위 객체인 전역객체(window)가 바인딩.</li>
<li>5번째 줄: window 객체 정보가 출력</li>
<li>9번째 줄: 호이스팅된 변수 obj2 역시 outer 스코프 내에서만 접근할 수 있는 지역변수이다. 여기에는 다시 객체를 할당하는데, 그 객체에는 innerMethod라는 프로퍼티가 있으며, 여기에는 앞서 정의된 변수 innerFunc와 연결된 익명 함수가 연결된다.</li>
<li>12번째 줄: obj2.innerMethod를 호출</li>
<li>9번째 줄: obj2.innerMethod 함수의 실행 컨텍스트가 생성됨. 이 함수는 호출할 때 함수명인 innerMethod 앞에 점(.)이 있었으므로 메서드로서 호출한 것. 따라서 this에는 마지막 점 앞의 객체인 obj2가 바인딩.</li>
<li>10번째 줄: obj2 객체 정보 출력</li>
</ul>
<p>7번째 줄에서는 outer 메서드 내부에 있는 함수(innerFunc)를 함수로서 호출했다. 반면 12번째 줄에서는 같은 함수(innerFunc)를 메서드로서 호출했다. 같은 함수임에도 7번째 줄에 의해 바인딩되는 this와 12번째 줄에 의해 바인딩되는 this의 대상이 서로 달라진 것이다.</p>
<p>그러니까 <code>this</code> 바인딩에 관해서는 함수를 실행하는 당시의 주변 환경(메서드 내부인지, 함수 내부인지 등)은 중요하지 않고, 오직 해당 함수를 호출하는 구문 앞에 점 또는 대괄호 표기가 있는지 없는지가 관건인 것이다.</p>
<p><strong>메서드의 내부 함수에서의 this를 우회하는 방법</strong></p>
<p>이렇게 하면 this에 대한 구분은 명확히 할 수 있지만, 그 결과 this라는 단어가 주는 인상과는 사뭇 달라져 버렸다. 호출 주체가 없을 때는 자동으로 전역객체를 바인딩하지 않고 호출 당시 주변 환경의 this를 그대로 상속받아 사용할 수 있다면 좋겠다. 그게 훨씬 자연스러울뿐더러 자바스크립트 설계상 이렇게 동작하는 편이 스코프 체인과의 일관성을 지키는 설득력 있는 방식이었다. 변수를 검새갛면 우선 가장 가까운 스코프의 L.E(LexicalEnvironment)를 찾고 없으면 상위 스코프를 탐색하듯이, this 역시 현재 컨텍스트에 바인딩된 대상이 없으면 직전 컨텍스트의 this를 바라보도록 말이다.</p>
<p>아쉽게도 ES5까지는 자체적으로 내부함수에 <code>this</code>를 상속할 방법이 없지만 다행히 이를 우회할 방법이 없지는 않다. 그중 대표적인 방법은 바로 변수를 활용하는 것이다.</p>
<p>[예제 10 내부함수에서의 this를 우회하는 방법]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  outer: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> innerFunc1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    innerFunc1();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> innerFunc2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(self);</span><br><span class="line">    &#125;;</span><br><span class="line">    innerFunc2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.outer();</span><br></pre></td></tr></table></figure>

<p>위 예제의 innerFunc1 내부에서 this는 전역객체를 가리킨다. 한편 outer 스코프에서 self라는 변수에 <code>this</code>를 저장한 상태에서 호출한 innerFunc2의 경우 self에는 객체 obj가 출력된다.</p>
<p><strong>this를 바인딩하지 않는 함수</strong></p>
<p>ES6에서는 함수 내부에서 this가 전역객체를 바라보는 문제를 보완하고자, this를 바인딩하지 않는 화살표 함수를 새로 도입했다. 화살표 함수는 실행 컨텍스트를 생성할 때 this 바인딩 과정 자체가 빠지게 되어, 상위 스코프의 this를 그대로 활용할 수 있다. 내부함수를 화살표 함수로 바꾸면 ‘우회법’이 불필요해진다.</p>
<p>[예제 11 this를 바인딩하지 않는 함수(화살표 함수)]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  outer: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// (1) &#123; outer: f &#125;</span></span><br><span class="line">    <span class="keyword">var</span> innerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// (2) &#123; outer: f &#125;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    innerFunc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.outer();</span><br></pre></td></tr></table></figure>

<p>그 밖에도 call, apply 등의 메서드를 활용해 함수를 호출할 때 명시적으로 this를 지정하는 방법이 있다.</p>
<h4 id="1-4-콜백-함수-호출-시-그-함수-내부에서의-this"><a href="#1-4-콜백-함수-호출-시-그-함수-내부에서의-this" class="headerlink" title="1-4. 콜백 함수 호출 시 그 함수 내부에서의 this"></a>1-4. 콜백 함수 호출 시 그 함수 내부에서의 this</h4><p>콜백 함수의 정의와 동작 원리 등에 대해서는 바로 다음장에서 자세히 다룬다. 여기서는 this가 어떤 값을 참조하는지만 간단히 확인하고 넘어간다.</p>
<p>함수 A의 제어권을 다른 함수(또는 메서드) B에게 넘겨주는 경우 함수 A를 콜백 함수라 한다. 이때 함수 A는 함수 B의 내부 로직에 따라 실행되며, this 역시 함수 B 내부 로직에서 정한 규칙에 따라 값이 결정된다. 콜백 함수도 함수이기 때문에 기본적으로 1-3 절에서와 마찬가지로 this가 전역객체를 참조하지만, 제어권을 받은 함수에서 콜백 함수에 별도로 this가 될 대상을 지정한 경우에는 그 대상을 참조하게 된다.</p>
<p>[예제 12 콜백 함수 내부에서의 this]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;, <span class="number">300</span>); <span class="comment">// (1)</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// (2)</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>, x);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.innerHTML += <span class="string">'&lt;button id="a"&gt;클릭&lt;/button&gt;'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.querySelector(<span class="string">"#a"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>, e); <span class="comment">// (3)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>(1): setTimeout 함수는 300ms 만큼 시간 지연을 한 뒤 콜백 함수를 실행하라는 명령이다. 0.3초 뒤 <u>전역객체</u>가 출력된다.</p>
<p>(2): forEach 메서드는 배열의 각 요소를 앞에서부터 차례로 하나씩 꺼내어 그 값을 콜백 함수의 첫 번째 인자로 삼아 함수를 실행하라는 명령이다. <u>전역객체와 배열의 각 요소</u>가 총 5회 출력된다.</p>
<p>(3): addEventListener는 지정한 HTML 엘리먼트에 ‘click’ 이벤트가 발생할 때마다 그 이벤트 정보를 콜백 함수의 첫 번째 인자로 삼아 함수를 실행하라는 명령이다. 버튼을 클릭하면 <u>앞서 지정한 엘리먼트와 클릭 이벤트</u>에 관한 정보가 담긴 객체가 출력된다.</p>
<p>(1)의 setTimeout 함수와 (2)의 forEach 메서드는 그 내부에서 콜백 함수를 호출할 때 대상이 될 this를 지정하지 않는다. 따라서 콜백 함수 내부에서의 this는 전역객체를 참조한다. 반면 (3)의 addEventListener 메서드는 콜백 함수를 호출할 때 자신의 this를 상속하도록 정의돼 있다. 그러니까 메서드명의 점(.) 앞부분이 곧 this가 되는 것이다.</p>
<p>이처럼 콜백 함수에서의 this는 ‘무조건 이거다’라고 정의할 수 없다. 콜백 함수의 제어권을 가지는 함수(메서드)가 콜백 함수에서의 this를 무엇으로 할지를 결정하며, 특별히 정의하지 않은 경우에는 기본적으로 함수와 마찬가지로 전역객체를 바라본다.</p>
<h4 id="1-5-생성자-함수-내부에서의-this"><a href="#1-5-생성자-함수-내부에서의-this" class="headerlink" title="1-5. 생성자 함수 내부에서의 this"></a>1-5. 생성자 함수 내부에서의 this</h4><p>생성자 함수는 어떤 공통된 성질을 지니는 객체들을 생성하는 데 사용하는 함수이다. 객체지향 언어에서는 생성자를 클래스, 클래스를 통해 만든 객체를 인스턴스라 한다.</p>
<p>프로그래밍적으로 ‘생성자’는 <strong>구체적인 인스턴스를 만들기 위한 일종의 틀</strong>이다. 이 틀에는 해당 클래스의 공통 속성들이 미리 준비돼 있고, 여기에 구체적인 인스턴스의 개성을 더해 개별 인스턴스를 만들 수 있는 것이다.</p>
<p>자바스크립트는 함수에 생성자로서의 역할을 함께 부여했다. <code>new</code> 명령어와 함께 함수를 호출하면 해당 함수가 생성자로서 동작하게 된다. 그리고 어떤 함수가 생성자 함수로서 호출된 경우 내부에서의 <code>this</code>는 곧 새로 만들 구체적인 인스턴스 자신이 된다.</p>
<p>생성자 함수를 호출(new 명령어와 함께 호출)하면 우선 생성자의 prototype 프로퍼티를 참조하는 <code>__proto__</code>라는 프로퍼티가 있는 객체(인스턴스)를 만들고, 미리 준비된 공통 속성 및 개성을 해당 객체(this)에 부여한다. 이렇게 해서 구체적인 인스턴스가 만들어진다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Cat = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.bark = <span class="string">"야옹"</span>;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  thia.age = age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> choco = <span class="keyword">new</span> Cat(<span class="string">"초코"</span>, <span class="number">7</span>);</span><br><span class="line"><span class="keyword">var</span> nabi = <span class="keyword">new</span> Cat(<span class="string">"나비"</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(choco, nabi);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 결과</span></span><br><span class="line"><span class="comment">Cat &#123; bark: '야옹', name: '초코', age: 7 &#125;</span></span><br><span class="line"><span class="comment">Cat &#123; bark: '야옹', name: '나비', age: 5 &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>Cat이란 변수에 익명 함수를 할당했다. 이 함수 내부에서는 this에 접근해서 bark, name, age 프로퍼티에 각각 값을 대입한다. 6번째와 7번째 줄에서는 new 명령어와 함께 Cat 함수를 호출해서 변수 choco, nabi에 각각 할당했다. 8번째 줄에서는 choco와 nabi를 출력해보니 각각 Cat 클래스의 인스턴스 객체가 출력된다. 즉 6번째 줄에서 실행한 생성자 함수 내부에서의 this는 choco 인스턴스를, 7번째 줄에서 실행한 생성자 함수 내부에서의 this는 nabi 인스턴스를 가리킴을 알 수 있다.</p>
<p>출처 : <a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId>=206513031" target="_blank" rel="noopener">코어 자바스크립트</a></p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">태그</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/Javascript/">Javascript</a> <a class="tag tag--primary tag--small t-link" href="/tags/this/">this</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a
                        class="post-action-btn btn btn--disabled"
                        aria-hidden="true"
                    >
                        
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/02/16/Javascript-실행-컨텍스트/"
                    data-tooltip="[Javascript] 실행 컨텍스트"
                    aria-label="다음: [Javascript] 실행 컨텍스트"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cok2exe.github.io/2020/03/01/Javascript-this/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cok2exe.github.io/2020/03/01/Javascript-this/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://cok2exe.github.io/2020/03/01/Javascript-this/"
                    title="Google+에 공유하기"
                    aria-label="Google+에 공유하기"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 dajyu. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a
                        class="post-action-btn btn btn--disabled"
                        aria-hidden="true"
                    >
                        
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/02/16/Javascript-실행-컨텍스트/"
                    data-tooltip="[Javascript] 실행 컨텍스트"
                    aria-label="다음: [Javascript] 실행 컨텍스트"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cok2exe.github.io/2020/03/01/Javascript-this/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cok2exe.github.io/2020/03/01/Javascript-this/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://cok2exe.github.io/2020/03/01/Javascript-this/"
                    title="Google+에 공유하기"
                    aria-label="Google+에 공유하기"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://cok2exe.github.io/2020/03/01/Javascript-this/"
                        aria-label="Facebook에 공유하기"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Facebook에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://cok2exe.github.io/2020/03/01/Javascript-this/"
                        aria-label="Twitter에 공유하기"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Twitter에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=https://cok2exe.github.io/2020/03/01/Javascript-this/"
                        aria-label="Google+에 공유하기"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Google+에 공유하기</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/over.jpg" alt="저자 이미지"/>
        
            <h4 id="about-card-name">dajyu</h4>
        
            <div id="about-card-bio"><p>혼잣말 공부러(코드사냥꾼)</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Web frontend</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Asia/Seoul
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->


    




    </body>
</html>
