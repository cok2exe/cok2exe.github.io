
<!DOCTYPE html>
<html lang="ko">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="공부방">
    <title>[Javascript] 클로저 - 공부방</title>
    <meta name="author" content="dajyu">
    
        <meta name="keywords" content="React,Typescript,HTML,CSS,Frontend,">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"dajyu","sameAs":["https://github.com/cok2exe","http://stackoverflow.com/cok2exe"],"image":"over.jpg"},"articleBody":"\nMDN에서는 클로저에 대해 “A closure is the combination of a function and the lexical environment within which that function was declared.” 라고 소개한다. 직역하면, “클로저는 함수와 그 함수가 선언될 당시의 lexical environment의 상호관계에 따른 현상” 이다.\n\n\n\n1. 클로저의 의미 및 원리 이해‘선언될 당시의 lexical environment’는 실행 컨텍스트의 구성 요소 중 하나인 outerEnvironmentReference에 해당한다. LexicalEnvironment의 environmentRecord와 outerEnvironmentReference에 의해 변수의 유효범위인 스코프가 결정되고 스코프 체인이 가능해진다. 어떤 컨텍스트 A에서 선언한 내부함수 B의 실행 컨텍스트가 활성화된 시점에는 B의 outerEnvironmentReference가 참조하는 대상인 A의 LexicalEnvironment에도 접근이 가능할 것이다. A에서는 B에서 선언한 변수에 접근할 수 없지만 B에서는 A에서 선언한 변수에 접근 가능하다.\n여기서 ‘combination’의 의미를 파악할 수 있다. 내부함수 B가 A의 LexicalEnvironment를 언제나 사용하는 것은 아니다. 내부함수에서 외부 변수를 참조하지 않는 경우라면 combination이라고 할 수 없다. 내부함수에서 외부 변수를 참조하는 경우에 한해서만 combination, 즉 ‘선언될 당시의 LexicalEnvironment와의 상호관계’가 의미가 있을 것이다.\n지금까지 파악한 내용에 따르면 클로저란 “어떤 함수에서 선언한 변수를 참조하는 내부함수에서만 발생하는 현상”이라고 볼 수 있다.\n[예제 1] 외부 함수의 변수를 참조하는 내부 함수(1)\n12345678var outer = function() &#123;  var a = 1;  var inner = function() &#123;    console.log(++a);  &#125;;  inner();&#125;;outer();\n\n예제 1에서는 outer 함수에서 변수 a를 선언했고, outer의 내부함수인 inner 함수에서 a의 값을 1만큼 증가시킨 다음 출력한다. inner 함수 내부에서는 a를 선언하지 않았기 때문에 environmentRecord에서 값을 찾지 못하므로 outerEnvironmentReference에 지정된 상위 컨텍스트인 outer의 LexicalEnvironment에 접근해서 다시 a를 찾는다. 4번째 줄에서는 2가 출력된다. outer 함수의 실행 컨텍스트가 종료되면 LexicalEnvironment에 저장된 식별자들(a, inner)에 대한 참조를 지운다. 그러면 각 주소에 저장돼 있던 값들은 자신을 참조하는 변수가 하나도 없게 되므로 가비지 컬렉터의 수집 대상이 될 것이다.\n[예제 2] 외부 함수의 변수를 참조하는 내부 함수(2)\n123456789var outer = function() &#123;  var a = 1;  var inner = function() &#123;    return ++a;  &#125;;  return inner();&#125;;var outer2 = outer();console.log(outer2());\n\n이번에도 inner 함수 내부에서 외부변수인 a를 사용했다. 그런데 6번째 줄에서는 inner 함수를 실행한 결과를 리턴하고 있으므로 결과적으로 outer 함수의 실행 컨텍스트가 종료된 시점에는 a 변수를 참조하는 대상이 없어진다. 예제 1과 마찬가지로 a, inner 변수의 값들은 언젠가 가비지 컬렉터에 의해 소멸할 것이다.\n예제 1과 2는 outer 함수의 실행 컨텍스트가 종료되기 이전에 inner 함수의 실행 컨텍스트가 종료돼 있으며, 이후 별도로 inner 함수를 호출할 수 없다는 공통점이 있다. 그렇다면 outer의 실행 컨텍스트가 종료된 후에도 inner 함수를 호출할 수 있게 만들면 어떨까?\n[예제 3] 외부 함수의 변수를 참조하는 내부 함수(3)\n12345678910var outer = function() &#123;  var a = 1;  var inner = function() &#123;    return ++a;  &#125;;  return inner;&#125;;var outer2 = outer();console.log(outer2()); // 2console.log(outer2()); // 3\n\n6번째 줄에서 inner 함수의 실행 결과가 아닌 inner 함수 자체를 반환했다. 그러면 outer 함수의 실행 컨텍스트가 종료될 때(8번째 줄) outer2 변수는 outer의 실행 결과인 inner 함수를 참조하게 될 것이다. 이후 9번째에서 outer2를 호출하면 앞서 반환된 함수인 inner가 실행될 것이다.\ninner 함수의 실행 컨텍스트의 environmentRecord에는 수집할 정보가 없다. outerEnvironmentReference에는 inner 함수가 선언된 위치의 LexicalEnvrionment가 참조복사된다. inner 함수는 outer 함수 내부에서 선언됐으므로, outer 함수의 LexicalEnvironment가 담길 것이다. 이제 스코프 체이닝에 따라 outer에서 선언한 변수 a에 접근해서 1만큼 증가시킨 후 그 값인 2를 반환하고, inner 함수의 실행 컨텍스트가 종료된다. 10번째 줄에서 다시 outer2를 호출하면 같은 방식으로 a의 값을 2에서 3으로 1 증가시킨 후 3을 반환한다.\ninner 함수의 실행 시점에는 outer 함수는 이미 실행이 종료된 상태인데 outer 함수의 LexicalEnvironment에 어떻게 접근할 수 있는 걸까? 이는 가비지 컬렉터의 동작 방식 때문이다. 가비지 컬렉터는 어떤 값을 참조하는 변수가 하나라도 있다면 그 값은 수집 대상에 포함시키지 않는다. 예제 3의 outer 함수는 실행 종료 시점에 inner 함수를 반환한다. 외부함수인 outer의 실행이 종료되더라도 내부 함수인 inner 함수는 언젠가 outer2를 실행함으로써 호출될 가능성이 열린 것이다. 언젠가 inner 함수의 실행 컨텍스트가 활성화되면 outerEnvironmentReference가 outer 함수의 LexicalEnvironment를 필요로 할 것이므로 수집 대상에서 제외된다. 그 덕에 inner 함수가 이 변수에 접근할 수 있는 것이다.\n클로저는 어떤 함수에서 선언한 변수를 참조하는 내부함수에서만 발생하는 현상이다. 이는 즉 “외부 함수의 LexicalEnvironment가 가비지 컬렉팅되지 않는 현상”을 말하는 것이다.\n이를 바탕으로 정의를 다시 고쳐보면 이렇다. 클로저란 어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우 A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상을 말한다.\n여기서 한 가지 주의할 점은, ‘외부로 전달’이 곧 return만을 의미하는 것은 아니라는 점이다.\n[예제 4] return 없이도 클로저가 발생하는 다양한 경우\n123456789101112// (1) setInterval/setTimeout(function() &#123;  var a = 0;  var intervalId = null;  var inner = function() &#123;    if (++a &gt;= 10) &#123;      clearInterval(intervalId);    &#125;    console.log(a);  &#125;;  intervalId = setInterval(inner, 1000);&#125;)();\n\n12345678910// eventListener(function() &#123;  var count = 0;  var button = document.createElement(\"button\");  button.innerText = \"click\";  button.addEventListener(\"click\", function() &#123;    console.log(++count, \"times clicked\");  &#125;);  document.body.appendChild(button);&#125;)();\n\n(1)은 별도의 외부객체인 window의 메서드(setTimeout or setInterval)에 전달할 콜백 함수 내부에서 지역변수를 참조한다. (2)는 별도의 외부객체인 DOM의 메서드(addEventListener)에 등록할 handler 함수 내부에서 지역변수를 참조한다. 두 상황 모두 지역변수를 참조하는 내부함수를 외부에 전달했기 때문에 클로저이다.\n\n2. 클로저와 메모리 관리메모리 누수의 위험을 이유로 클로저 사용을 조심해야 한다거나 심지어 지양해야 한다고 주장하는 사람들도 있지만 메모리 소모는 클로저의 본질적인 특성일 뿐이다. 오히려 이러한 특성을 정확히 이해하고 잘 활용하도록 노력해야 한다.\n관리 방법은 정말 간단하다. 클로저는 어떤 필요에 의해 의도적으로 함수의 지역변수를 메모리를 소모하도록 함으로써 발생한다. 그렇다면 그 필요성이 사라진 시점에는 더는 메모리를 소모하지 않게 해주면 된다. 참조 카운트를 0으로 만들면 언젠가 GC가 수거해갈 것이고, 이때 소모됐던 메모리가 회수될 것이다. 식별자에 참조형이 아닌 기본형 데이터(보통 null이나 undefined)를 할당하면 된다.\n[예제 5] 클로저의 메모리 관리\n1234567891011// (1) return에 의한 클로저의 메모리 해제var outer = (function() &#123;  var a = 1;  var inner = function() &#123;    return ++a;  &#125;;  return inner;&#125;)();console.log(outer());console.log(outer());outer = null; // outer 식별자의 inner 함수 참조를 끊음\n\n12345678910111213// (2) setInterval에 의한 클로저의 메모리 해제(function() &#123;  var a = 0;  var intervalId = null;  var inner = function() &#123;    if (++a &gt;= 10) &#123;      clearInterval(intervalId);      inner = null; // inner 식별자의 함수 참조를 끊음    &#125;    console.log(a);  &#125;;  intervalId = setInterval(inner, 1000);&#125;)();\n\n12345678910111213141516// (3) eventListener에 의한 클로저의 메모리 해제(function() &#123;  var count = 0;  var button = document.createElement(\"button\");  button.innerText = \"click\";  var clickHandler = function() &#123;    console.log(++count, \"times clicked\");    if (count &gt;= 10) &#123;      button.removeEventListener(\"click\", clickHandler);      clickHandler = null; // clickHandler 식별자의 함수 참조를 끊음    &#125;  &#125;;  button.addEventListener(\"click\", clickHandler);  document.body.appendChild(button);&#125;)();\n\n\n3. 클로저 활용 사례3-1. 콜백 함수 내부에서 외부 데이터를 사용하고자 할 때1234567891011121314var fruits = [\"apple\", \"banana\", \"peach\"];var $ul = document.createElement(\"ul\");fruits.forEach(function(fruit) &#123;  // (A)  var $li = document.createElement(\"li\");  $li.innerText = fruit;  $li.addEventListener(\"click\", function() &#123;    // (B)    alert(\"your choice is \" + fruit);  &#125;);  $ul.appenChild($li);&#125;);document.body.appendChild($ul);\n\n4번째 줄의 forEach 메서드에 넘겨준 익명의 콜백 함수 (A)는 그 내부에서 외부 변수를 사용하지 않고 있으므로 클로저가 없지만, 7번째 줄의 addEventListener에 넘겨준 콜백 함수 (B)에는 fruit이라는 외부 변수를 참조하고 있으므로 클로저가 있다. (A)는 fruits의 개수만큼 실행되며, 그때마다 새로운 실행 컨텍스트가 활성화될 것이다. A의 실행 종료 여부와 무관하게 클릭 이벤트에 의해 각 컨텍스트의 (B)가 실행될 때는 (B)의 outerEnvironmentReference가 (A)의 LexicalEnvironment를 참조하게 될 것이다. 따라서 최소한 (B) 함수가 참조할 예정인 변수 fruit에 대해서는 (A)가 종료된 후에도 GC 대상에서 제외되어 계속 참조 가능할 것이다.\n123456789101112131415var fruits = [\"apple\", \"banana\", \"peach\"];var $ul = document.createElement(\"ul\");var alertFruit = function(fruit) &#123;  alert(\"your choice is \" + fruit);&#125;;fruits.forEach(function(fruit) &#123;  // (A)  var $li = document.createElement(\"li\");  $li.innerText = fruit;  $li.addEventListener(\"click\", alertFruit.bind(null, fruit));  $ul.appenChild($li);&#125;);document.body.appendChild($ul);\n\nbind를 써서 this를 fruit으로 넘겨줄 수 있다. bind를 쓰지 않았을 때는 [object MouseEvent]가 출력되는데, 이는 콜백 함수를 호출할 때 첫 번째 인자에 ‘이벤트 객체’를 주입하기 때문이다. bind를 써서 문제는 해결할 수 있지만, this가 원래의 그것과 달라지는 점은 감안해야 한다. 다른 방안으로는 고차함수를 활용하는 것이다.\n1234567891011121314151617var fruits = [\"apple\", \"banana\", \"peach\"];var $ul = document.createElement(\"ul\");var alertFruitBuilder = function(fruit) &#123;  return function() &#123;    alert(\"your choice is \" + fruit);  &#125;;&#125;;fruits.forEach(function(fruit) &#123;  // (A)  var $li = document.createElement(\"li\");  $li.innerText = fruit;  $li.addEventListener(\"click\", alertFruitBuilder(fruit));  $ul.appenChild($li);&#125;);document.body.appendChild($ul);\n\nalertFruitBuilder 함수 내부에서는 다시 익명함수를 반환하는데, 이 익명함수가 바로 기존의 alertFruit 함수이다. 12번째 줄에서 alertFruitBuilder 함수를 실행하면서 fruit 값을 인자로 전달했다. 그러면 이 함수의 실행 결과가 다시 함수가 되며, 이렇게 반환된 함수를 리스너에 콜백 함수로써 전달할 것이다. 이후 언젠가 클릭 이벤트가 발생하면 비로소 이 함수의 실행 컨텍스트가 열리면서 alertFruitBuilder의 인자로 넘어온 fruit를 outerEnvironmentReference에 의해 참조할 수 있다. 즉 alertFruitBuilder의 실행 결과로 반환된 함수에는 클로저가 존재한다.\n3-2. 접근 권한 제어(정보 은닉)정보 은닉은 어떤 모듈의 내부 로직에 대해 외부로의 노출을 최소화해서 모듈간의 결합도를 낮추고 유연성을 높이고자 하는 현대 프로그래밍 언어의 중요한 개념 중 하나이다. 흔히 접근 권한에는 public, private, protected 세 종류가 있다. 각 단어의 의미 그대로, public은 외부에서 접근 가능한 것이고, private은 내부에서만 사용하며 외부에 노출되지 않는 것을 의미한다.\n자바스크립트는 기본적으로 변수 자체에 이러한 접근 권한을 직접 부여하도록 설계돼 있지 않다. 그렇다고 접근 권한 제어가 불가능한 것은 아니다. 클로저를 이용하면 함수 차원에서 public한 값과 private한 값을 구분하는 것이 가능하다.\n클로저를 활용하면 외부 스코프에서 함수 내부의 변수들 중 선택적으로 일부의 변수에 대한 접근 권한을 부여할 수 있다. 바로 return을 활용해서 말이다.\n외부에 제공하고자 하는 정보들을 모아서 return하고, 내부에서만 사용할 정보들은 return하지 않는 것으로 접근 권한 제어가 가능한 것이다. return한 변수들은 공개 멤버가 되고, 그렇지 않은 변수들은 비공개 멤버가 되는 것이다.\n클로저를 활용해 접근권한을 제어하는 방법은 다음과 같다.\n\n함수에서 지역변수 및 내부함수 등을 생성한다.\n외부에 접근권한을 주고자 하는 대상들로 구성된 참조형 데이터(대상이 여럿일 때는 객체 또는 배열, 하나일 때는 함수)를 return 한다. -&gt; return 한 변수들은 공개 멤버가 되고, 그렇지 않은 변수들은 비공개 멤버가 된다.\n\n3-3. 부분 적용 함수부분 적용 함수란 n개의 인자를 받는 함수에 미리 m개의 인자만 넘겨 기억시켰다가, 나중에 (n-m)개의 인자를 넘기면 비로소 원래 함수의 실행 결과를 얻을 수 있게끔 하는 함수이다.\n실무에서 부분 함수를 사용하기에 적합한 예로 디바운스가 있다. 디바운스는 짧은 시간 동안 동일한 이벤트가 많이 발생할 경우 이를 전부 처리하지 않고 처음 또는 마지막에 발생한 이벤트에 대해 한 번만 처리하는 것으로, 프론트엔드 성능 최적화에 도움을 주는 기능 중 하나이다. scroll, wheel, mousemove, resize 등에 적용하기 좋다.\n1234567891011121314151617181920212223var debounce = function(eventName, func, wait) &#123;  var timeoutId = null;  return function(event) &#123;    var self = this;    console.log(eventName, \"event 발생\");    clearTimeout(timeoutId);    timeoutId = setTimeout(func.bind(self, event), wait);  &#125;;&#125;;var moveHandler = function(e) &#123;  console.log(\"move evnet 처리\");&#125;;var wheelHandler = function(e) &#123;  console.log(\"wheel event 처리\");&#125;;document.body.addEventListener(\"mousemove\", debounce(\"move\", moveHandler, 500));document.body.addEventListener(  \"mousewheel\",  debounce(\"wheel\", wheelHandler, 700));\n\n3-4. 커링 함수커링 함수란 여러 개의 인자를 받는 함수를 하나의 인자만 받는 함수로 나눠서 순차적으로 호출될 수 있게 체인 형태로 구성한 것을 말한다. 중간 과정상의 함수를 실행한 결과는 그다음 인자를 받기 위해 대기만 할 뿐으로, 마지막 인자가 전달되기 전까지는 원본 함수가 실행되지 않는다. (부분 적용 함수는 여러 개의 인자를 전달할 수 있고, 실행 결과를 재실행할 때 원본 함수가 무조건 실행된다.)\n123456789101112131415var curry3 = function(func) &#123;  return function(a) &#123;    return function(b) &#123;      return func(a, b);    &#125;;  &#125;;&#125;;var getMaxWith10 = curry3(Math.max)(10);console.log(getMaxWith10(8)); // 10console.log(getMaxWith10(25)); // 25var getMinWith10 = curry3(Math.min)(10);console.log(getMinWith10(8)); // 8console.log(getMinWith10(25)); // 10\n\n부분 적용 함수와 달리 커링 함수는 필요한 상황에 직접 만들어 쓰기 용이하다. 필요한 인자 개수만큼 함수를 만들어 계속 리턴해주다가 마지막에만 짠! 하고 조합해서 리턴해주면 되기 때문이다.\n화살표 함수로 구현하면 커링 함수를 이해하기에 훨씬 수월하다.\n커링 함수가 유용한 경우가 있다. 당장 필요한 정보만 받아서 전달하고 또 필요한 정보가 들어오면 전달하는 식으로 하면 결국 마지막 인자가 넘어갈 때까지 함수 실행을 미루는 셈이 된다. 이를 함수형 프로그래밍에서는 지연실행이라고 칭한다. 원하는 시점까지 지연시켰다가 실행하는 것이 요긴한 상황이라면 커링을 쓰기에 적합한 것이다. 혹은 프로젝트 내에서 자주 쓰이는 함수의 매개변수가 항상 비슷하고 일부만 바뀌는 경우에도 적절한 후보가 될 것이다.\n12345678910var getInformation = function(baseUrl) &#123;  return function(path) &#123;    return function(id) &#123;      return fetch(baseUrl + path + \"/\" + id); // 실제 서버에 정보 요청    &#125;;  &#125;;&#125;;// ES6var getInformation = baseUrl =&gt; path =&gt; id =&gt; fetch(baseUrl + path + \"/\" + id);\n\nHTML5의 fetch 함수는 url을 받아 해당 url에 HTTP 요청을 한다. 보통 REST API를 이용할 경우 baseUrl은 몇 개로 고정되지만 나머지 path나 id 값은 매우 많을 수 있다. 이런 상황에서 서버에 정보를 요청할 필요가 있을 때마다 매번 baseUrl부터 전부 기입해주기보다는 공통적인 요소는 먼저 기억시켜두고 특정한 값(id)만으로 서버 요청을 수행하는 함수를 만들어두는 편이 개발 효율성이나 가독성 측면에서 더 좋을 것이다.\n\n4. 정리클로저란 어떤 함수에서 선언한 변수를 참조하는 내부함수를 외부로 전달할 경우, 함수의 실행 컨텍스트가 종료된 후에도 해당 변수가 사라지지 않는 현상이다.\n내부함수를 외부로 전달하는 방법에는 함수를 return하는 경우뿐 아니라 콜백으로 전달하는 경우도 포함된다.\n클로저는 그 본질이 메모리를 계속 차지하는 개념이므로 더는 사용하지 않게 된 클로저에 대해서는 메모리를 차지하지 않도록 관리해줄 필요가 있다.\n출처 : 코어 자바스크립트\n","dateCreated":"2020-03-15T10:20:20+09:00","dateModified":"2020-03-15T13:02:17+09:00","datePublished":"2020-03-15T10:20:20+09:00","description":"\nMDN에서는 클로저에 대해 “A closure is the combination of a function and the lexical environment within which that function was declared.” 라고 소개한다. 직역하면, “클로저는 함수와 그 함수가 선언될 당시의 lexical environment의 상호관계에 따른 현상” 이다.\n","headline":"[Javascript] 클로저","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://cok2exe.github.io/2020/03/15/Javascript-클로저/"},"publisher":{"@type":"Organization","name":"dajyu","sameAs":["https://github.com/cok2exe","http://stackoverflow.com/cok2exe"],"image":"over.jpg","logo":{"@type":"ImageObject","url":"over.jpg"}},"url":"https://cok2exe.github.io/2020/03/15/Javascript-클로저/","keywords":"Javascript, 클로저"}</script>
    <meta name="description" content="MDN에서는 클로저에 대해 “A closure is the combination of a function and the lexical environment within which that function was declared.” 라고 소개한다. 직역하면, “클로저는 함수와 그 함수가 선언될 당시의 lexical environment의 상호관계에 따른 현">
<meta name="keywords" content="Javascript,클로저">
<meta property="og:type" content="blog">
<meta property="og:title" content="[Javascript] 클로저">
<meta property="og:url" content="https://cok2exe.github.io/2020/03/15/Javascript-클로저/index.html">
<meta property="og:site_name" content="공부방">
<meta property="og:description" content="MDN에서는 클로저에 대해 “A closure is the combination of a function and the lexical environment within which that function was declared.” 라고 소개한다. 직역하면, “클로저는 함수와 그 함수가 선언될 당시의 lexical environment의 상호관계에 따른 현">
<meta property="og:locale" content="ko">
<meta property="og:updated_time" content="2020-03-15T04:02:17.282Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[Javascript] 클로저">
<meta name="twitter:description" content="MDN에서는 클로저에 대해 “A closure is the combination of a function and the lexical environment within which that function was declared.” 라고 소개한다. 직역하면, “클로저는 함수와 그 함수가 선언될 당시의 lexical environment의 상호관계에 따른 현">
    
    
        
    
    
        <meta property="og:image" content="https://cok2exe.github.io/assets/images/over.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            공부방
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="링크 열기: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/over.jpg" alt="저자 이미지"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="저자에 대해 더 알아보기"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/over.jpg" alt="저자 이미지"/>
                </a>
                <h4 class="sidebar-profile-name">dajyu</h4>
                
                    <h5 class="sidebar-profile-bio"><p>혼잣말 공부러(코드사냥꾼)</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="Home"
                        >
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                            title="About"
                        >
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/cok2exe" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="http://stackoverflow.com/cok2exe" target="_blank" rel="noopener" title="Stack Overflow">
                    
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            [Javascript] 클로저
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2020-03-15T10:20:20+09:00">
	
		    2020/03/15
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/Javascript/">Javascript</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <blockquote>
<p>MDN에서는 클로저에 대해 “A closure is the combination of a function and the lexical environment within which that function was declared.” 라고 소개한다. 직역하면, “클로저는 함수와 그 함수가 선언될 당시의 lexical environment의 상호관계에 따른 현상” 이다.</p>
</blockquote>
<a id="more"></a>

<h3 id="1-클로저의-의미-및-원리-이해"><a href="#1-클로저의-의미-및-원리-이해" class="headerlink" title="1. 클로저의 의미 및 원리 이해"></a>1. 클로저의 의미 및 원리 이해</h3><p>‘선언될 당시의 lexical environment’는 실행 컨텍스트의 구성 요소 중 하나인 outerEnvironmentReference에 해당한다. <a href="https://cok2exe.github.io/2020/02/16/Javascript-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/#3-2-%EC%8A%A4%EC%BD%94%ED%94%84-%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B2%B4%EC%9D%B8-outerEnvironmentReference">LexicalEnvironment의 environmentRecord와 outerEnvironmentReference에 의해 변수의 유효범위인 스코프가 결정되고 스코프 체인이 가능해진다.</a> 어떤 컨텍스트 A에서 선언한 내부함수 B의 실행 컨텍스트가 활성화된 시점에는 B의 outerEnvironmentReference가 참조하는 대상인 A의 LexicalEnvironment에도 접근이 가능할 것이다. A에서는 B에서 선언한 변수에 접근할 수 없지만 B에서는 A에서 선언한 변수에 접근 가능하다.</p>
<p>여기서 ‘combination’의 의미를 파악할 수 있다. 내부함수 B가 A의 LexicalEnvironment를 언제나 사용하는 것은 아니다. 내부함수에서 외부 변수를 참조하지 않는 경우라면 combination이라고 할 수 없다. 내부함수에서 외부 변수를 참조하는 경우에 한해서만 combination, 즉 ‘선언될 당시의 LexicalEnvironment와의 상호관계’가 의미가 있을 것이다.</p>
<p>지금까지 파악한 내용에 따르면 클로저란 “어떤 함수에서 선언한 변수를 참조하는 내부함수에서만 발생하는 현상”이라고 볼 수 있다.</p>
<p>[예제 1] 외부 함수의 변수를 참조하는 내부 함수(1)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(++a);</span><br><span class="line">  &#125;;</span><br><span class="line">  inner();</span><br><span class="line">&#125;;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure>

<p>예제 1에서는 outer 함수에서 변수 a를 선언했고, outer의 내부함수인 inner 함수에서 a의 값을 1만큼 증가시킨 다음 출력한다. inner 함수 내부에서는 a를 선언하지 않았기 때문에 environmentRecord에서 값을 찾지 못하므로 outerEnvironmentReference에 지정된 상위 컨텍스트인 outer의 LexicalEnvironment에 접근해서 다시 a를 찾는다. 4번째 줄에서는 2가 출력된다. outer 함수의 실행 컨텍스트가 종료되면 LexicalEnvironment에 저장된 식별자들(a, inner)에 대한 참조를 지운다. 그러면 각 주소에 저장돼 있던 값들은 자신을 참조하는 변수가 하나도 없게 되므로 가비지 컬렉터의 수집 대상이 될 것이다.</p>
<p>[예제 2] 외부 함수의 변수를 참조하는 내부 함수(2)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++a;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> inner();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> outer2 = outer();</span><br><span class="line"><span class="built_in">console</span>.log(outer2());</span><br></pre></td></tr></table></figure>

<p>이번에도 inner 함수 내부에서 외부변수인 a를 사용했다. 그런데 6번째 줄에서는 inner 함수를 실행한 결과를 리턴하고 있으므로 결과적으로 outer 함수의 실행 컨텍스트가 종료된 시점에는 a 변수를 참조하는 대상이 없어진다. 예제 1과 마찬가지로 a, inner 변수의 값들은 언젠가 가비지 컬렉터에 의해 소멸할 것이다.</p>
<p>예제 1과 2는 outer 함수의 실행 컨텍스트가 종료되기 이전에 inner 함수의 실행 컨텍스트가 종료돼 있으며, 이후 별도로 inner 함수를 호출할 수 없다는 공통점이 있다. 그렇다면 outer의 실행 컨텍스트가 종료된 후에도 inner 함수를 호출할 수 있게 만들면 어떨까?</p>
<p>[예제 3] 외부 함수의 변수를 참조하는 내부 함수(3)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++a;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> inner;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> outer2 = outer();</span><br><span class="line"><span class="built_in">console</span>.log(outer2()); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(outer2()); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>6번째 줄에서 inner 함수의 실행 결과가 아닌 inner 함수 자체를 반환했다. 그러면 outer 함수의 실행 컨텍스트가 종료될 때(8번째 줄) outer2 변수는 outer의 실행 결과인 inner 함수를 참조하게 될 것이다. 이후 9번째에서 outer2를 호출하면 앞서 반환된 함수인 inner가 실행될 것이다.</p>
<p>inner 함수의 실행 컨텍스트의 environmentRecord에는 수집할 정보가 없다. outerEnvironmentReference에는 inner 함수가 선언된 위치의 LexicalEnvrionment가 참조복사된다. inner 함수는 outer 함수 내부에서 선언됐으므로, outer 함수의 LexicalEnvironment가 담길 것이다. 이제 스코프 체이닝에 따라 outer에서 선언한 변수 a에 접근해서 1만큼 증가시킨 후 그 값인 2를 반환하고, inner 함수의 실행 컨텍스트가 종료된다. 10번째 줄에서 다시 outer2를 호출하면 같은 방식으로 a의 값을 2에서 3으로 1 증가시킨 후 3을 반환한다.</p>
<p>inner 함수의 실행 시점에는 outer 함수는 이미 실행이 종료된 상태인데 outer 함수의 LexicalEnvironment에 어떻게 접근할 수 있는 걸까? 이는 가비지 컬렉터의 동작 방식 때문이다. 가비지 컬렉터는 어떤 값을 참조하는 변수가 하나라도 있다면 그 값은 수집 대상에 포함시키지 않는다. 예제 3의 outer 함수는 실행 종료 시점에 inner 함수를 반환한다. 외부함수인 outer의 실행이 종료되더라도 내부 함수인 inner 함수는 언젠가 outer2를 실행함으로써 호출될 가능성이 열린 것이다. 언젠가 inner 함수의 실행 컨텍스트가 활성화되면 outerEnvironmentReference가 outer 함수의 LexicalEnvironment를 필요로 할 것이므로 수집 대상에서 제외된다. 그 덕에 inner 함수가 이 변수에 접근할 수 있는 것이다.</p>
<p>클로저는 어떤 함수에서 선언한 변수를 참조하는 내부함수에서만 발생하는 현상이다. 이는 즉 “외부 함수의 LexicalEnvironment가 가비지 컬렉팅되지 않는 현상”을 말하는 것이다.</p>
<p>이를 바탕으로 정의를 다시 고쳐보면 이렇다. <strong>클로저란 어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우 A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상</strong>을 말한다.</p>
<p>여기서 한 가지 주의할 점은, ‘외부로 전달’이 곧 return만을 의미하는 것은 아니라는 점이다.</p>
<p>[예제 4] return 없이도 클로저가 발생하는 다양한 경우</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (1) setInterval/setTimeout</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> intervalId = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (++a &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      clearInterval(intervalId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;;</span><br><span class="line">  intervalId = setInterval(inner, <span class="number">1000</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eventListener</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> button = <span class="built_in">document</span>.createElement(<span class="string">"button"</span>);</span><br><span class="line">  button.innerText = <span class="string">"click"</span>;</span><br><span class="line">  button.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(++count, <span class="string">"times clicked"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(button);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>(1)은 별도의 외부객체인 window의 메서드(setTimeout or setInterval)에 전달할 콜백 함수 내부에서 지역변수를 참조한다. (2)는 별도의 외부객체인 DOM의 메서드(addEventListener)에 등록할 handler 함수 내부에서 지역변수를 참조한다. 두 상황 모두 지역변수를 참조하는 내부함수를 외부에 전달했기 때문에 클로저이다.</p>
<hr>
<h3 id="2-클로저와-메모리-관리"><a href="#2-클로저와-메모리-관리" class="headerlink" title="2. 클로저와 메모리 관리"></a>2. 클로저와 메모리 관리</h3><p>메모리 누수의 위험을 이유로 클로저 사용을 조심해야 한다거나 심지어 지양해야 한다고 주장하는 사람들도 있지만 메모리 소모는 클로저의 본질적인 특성일 뿐이다. 오히려 이러한 특성을 정확히 이해하고 잘 활용하도록 노력해야 한다.</p>
<p>관리 방법은 정말 간단하다. 클로저는 어떤 필요에 의해 의도적으로 함수의 지역변수를 메모리를 소모하도록 함으로써 발생한다. 그렇다면 그 필요성이 사라진 시점에는 더는 메모리를 소모하지 않게 해주면 된다. 참조 카운트를 0으로 만들면 언젠가 GC가 수거해갈 것이고, 이때 소모됐던 메모리가 회수될 것이다. 식별자에 참조형이 아닌 기본형 데이터(보통 null이나 undefined)를 할당하면 된다.</p>
<p>[예제 5] 클로저의 메모리 관리</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (1) return에 의한 클로저의 메모리 해제</span></span><br><span class="line"><span class="keyword">var</span> outer = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++a;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> inner;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(outer());</span><br><span class="line"><span class="built_in">console</span>.log(outer());</span><br><span class="line">outer = <span class="literal">null</span>; <span class="comment">// outer 식별자의 inner 함수 참조를 끊음</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (2) setInterval에 의한 클로저의 메모리 해제</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> intervalId = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (++a &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      clearInterval(intervalId);</span><br><span class="line">      inner = <span class="literal">null</span>; <span class="comment">// inner 식별자의 함수 참조를 끊음</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;;</span><br><span class="line">  intervalId = setInterval(inner, <span class="number">1000</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (3) eventListener에 의한 클로저의 메모리 해제</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> button = <span class="built_in">document</span>.createElement(<span class="string">"button"</span>);</span><br><span class="line">  button.innerText = <span class="string">"click"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> clickHandler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(++count, <span class="string">"times clicked"</span>);</span><br><span class="line">    <span class="keyword">if</span> (count &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      button.removeEventListener(<span class="string">"click"</span>, clickHandler);</span><br><span class="line">      clickHandler = <span class="literal">null</span>; <span class="comment">// clickHandler 식별자의 함수 참조를 끊음</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  button.addEventListener(<span class="string">"click"</span>, clickHandler);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(button);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-클로저-활용-사례"><a href="#3-클로저-활용-사례" class="headerlink" title="3. 클로저 활용 사례"></a>3. 클로저 활용 사례</h3><h4 id="3-1-콜백-함수-내부에서-외부-데이터를-사용하고자-할-때"><a href="#3-1-콜백-함수-내부에서-외부-데이터를-사용하고자-할-때" class="headerlink" title="3-1. 콜백 함수 내부에서 외부 데이터를 사용하고자 할 때"></a>3-1. 콜백 함수 내부에서 외부 데이터를 사용하고자 할 때</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"peach"</span>];</span><br><span class="line"><span class="keyword">var</span> $ul = <span class="built_in">document</span>.createElement(<span class="string">"ul"</span>);</span><br><span class="line"></span><br><span class="line">fruits.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">fruit</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// (A)</span></span><br><span class="line">  <span class="keyword">var</span> $li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">  $li.innerText = fruit;</span><br><span class="line">  $li.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// (B)</span></span><br><span class="line">    alert(<span class="string">"your choice is "</span> + fruit);</span><br><span class="line">  &#125;);</span><br><span class="line">  $ul.appenChild($li);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild($ul);</span><br></pre></td></tr></table></figure>

<p>4번째 줄의 forEach 메서드에 넘겨준 익명의 콜백 함수 (A)는 그 내부에서 외부 변수를 사용하지 않고 있으므로 클로저가 없지만, 7번째 줄의 addEventListener에 넘겨준 콜백 함수 (B)에는 fruit이라는 외부 변수를 참조하고 있으므로 클로저가 있다. (A)는 fruits의 개수만큼 실행되며, 그때마다 새로운 실행 컨텍스트가 활성화될 것이다. A의 실행 종료 여부와 무관하게 클릭 이벤트에 의해 각 컨텍스트의 (B)가 실행될 때는 (B)의 outerEnvironmentReference가 (A)의 LexicalEnvironment를 참조하게 될 것이다. 따라서 최소한 (B) 함수가 참조할 예정인 변수 fruit에 대해서는 (A)가 종료된 후에도 GC 대상에서 제외되어 계속 참조 가능할 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"peach"</span>];</span><br><span class="line"><span class="keyword">var</span> $ul = <span class="built_in">document</span>.createElement(<span class="string">"ul"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> alertFruit = <span class="function"><span class="keyword">function</span>(<span class="params">fruit</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"your choice is "</span> + fruit);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fruits.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">fruit</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// (A)</span></span><br><span class="line">  <span class="keyword">var</span> $li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">  $li.innerText = fruit;</span><br><span class="line">  $li.addEventListener(<span class="string">"click"</span>, alertFruit.bind(<span class="literal">null</span>, fruit));</span><br><span class="line">  $ul.appenChild($li);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild($ul);</span><br></pre></td></tr></table></figure>

<p>bind를 써서 this를 fruit으로 넘겨줄 수 있다. bind를 쓰지 않았을 때는 [object MouseEvent]가 출력되는데, 이는 콜백 함수를 호출할 때 첫 번째 인자에 ‘이벤트 객체’를 주입하기 때문이다. bind를 써서 문제는 해결할 수 있지만, this가 원래의 그것과 달라지는 점은 감안해야 한다. 다른 방안으로는 고차함수를 활용하는 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"peach"</span>];</span><br><span class="line"><span class="keyword">var</span> $ul = <span class="built_in">document</span>.createElement(<span class="string">"ul"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> alertFruitBuilder = <span class="function"><span class="keyword">function</span>(<span class="params">fruit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"your choice is "</span> + fruit);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fruits.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">fruit</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// (A)</span></span><br><span class="line">  <span class="keyword">var</span> $li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">  $li.innerText = fruit;</span><br><span class="line">  $li.addEventListener(<span class="string">"click"</span>, alertFruitBuilder(fruit));</span><br><span class="line">  $ul.appenChild($li);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild($ul);</span><br></pre></td></tr></table></figure>

<p>alertFruitBuilder 함수 내부에서는 다시 익명함수를 반환하는데, 이 익명함수가 바로 기존의 alertFruit 함수이다. 12번째 줄에서 alertFruitBuilder 함수를 실행하면서 fruit 값을 인자로 전달했다. 그러면 이 함수의 실행 결과가 다시 함수가 되며, 이렇게 반환된 함수를 리스너에 콜백 함수로써 전달할 것이다. 이후 언젠가 클릭 이벤트가 발생하면 비로소 이 함수의 실행 컨텍스트가 열리면서 alertFruitBuilder의 인자로 넘어온 fruit를 outerEnvironmentReference에 의해 참조할 수 있다. 즉 alertFruitBuilder의 실행 결과로 반환된 함수에는 클로저가 존재한다.</p>
<h4 id="3-2-접근-권한-제어-정보-은닉"><a href="#3-2-접근-권한-제어-정보-은닉" class="headerlink" title="3-2. 접근 권한 제어(정보 은닉)"></a>3-2. 접근 권한 제어(정보 은닉)</h4><p>정보 은닉은 어떤 모듈의 내부 로직에 대해 외부로의 노출을 최소화해서 모듈간의 결합도를 낮추고 유연성을 높이고자 하는 현대 프로그래밍 언어의 중요한 개념 중 하나이다. 흔히 접근 권한에는 public, private, protected 세 종류가 있다. 각 단어의 의미 그대로, public은 외부에서 접근 가능한 것이고, private은 내부에서만 사용하며 외부에 노출되지 않는 것을 의미한다.</p>
<p>자바스크립트는 기본적으로 변수 자체에 이러한 접근 권한을 직접 부여하도록 설계돼 있지 않다. 그렇다고 접근 권한 제어가 불가능한 것은 아니다. 클로저를 이용하면 함수 차원에서 public한 값과 private한 값을 구분하는 것이 가능하다.</p>
<p>클로저를 활용하면 외부 스코프에서 함수 내부의 변수들 중 선택적으로 일부의 변수에 대한 접근 권한을 부여할 수 있다. 바로 return을 활용해서 말이다.</p>
<p>외부에 제공하고자 하는 정보들을 모아서 return하고, 내부에서만 사용할 정보들은 return하지 않는 것으로 접근 권한 제어가 가능한 것이다. return한 변수들은 공개 멤버가 되고, 그렇지 않은 변수들은 비공개 멤버가 되는 것이다.</p>
<p>클로저를 활용해 접근권한을 제어하는 방법은 다음과 같다.</p>
<ol>
<li>함수에서 지역변수 및 내부함수 등을 생성한다.</li>
<li>외부에 접근권한을 주고자 하는 대상들로 구성된 참조형 데이터(대상이 여럿일 때는 객체 또는 배열, 하나일 때는 함수)를 return 한다. -&gt; return 한 변수들은 공개 멤버가 되고, 그렇지 않은 변수들은 비공개 멤버가 된다.</li>
</ol>
<h4 id="3-3-부분-적용-함수"><a href="#3-3-부분-적용-함수" class="headerlink" title="3-3. 부분 적용 함수"></a>3-3. 부분 적용 함수</h4><p>부분 적용 함수란 n개의 인자를 받는 함수에 미리 m개의 인자만 넘겨 기억시켰다가, 나중에 (n-m)개의 인자를 넘기면 비로소 원래 함수의 실행 결과를 얻을 수 있게끔 하는 함수이다.</p>
<p>실무에서 부분 함수를 사용하기에 적합한 예로 디바운스가 있다. 디바운스는 짧은 시간 동안 동일한 이벤트가 많이 발생할 경우 이를 전부 처리하지 않고 처음 또는 마지막에 발생한 이벤트에 대해 한 번만 처리하는 것으로, 프론트엔드 성능 최적화에 도움을 주는 기능 중 하나이다. scroll, wheel, mousemove, resize 등에 적용하기 좋다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> debounce = <span class="function"><span class="keyword">function</span>(<span class="params">eventName, func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeoutId = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(eventName, <span class="string">"event 발생"</span>);</span><br><span class="line">    clearTimeout(timeoutId);</span><br><span class="line">    timeoutId = setTimeout(func.bind(self, event), wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> moveHandler = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"move evnet 처리"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wheelHandler = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"wheel event 처리"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">"mousemove"</span>, debounce(<span class="string">"move"</span>, moveHandler, <span class="number">500</span>));</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(</span><br><span class="line">  <span class="string">"mousewheel"</span>,</span><br><span class="line">  debounce(<span class="string">"wheel"</span>, wheelHandler, <span class="number">700</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="3-4-커링-함수"><a href="#3-4-커링-함수" class="headerlink" title="3-4. 커링 함수"></a>3-4. 커링 함수</h4><p>커링 함수란 여러 개의 인자를 받는 함수를 하나의 인자만 받는 함수로 나눠서 순차적으로 호출될 수 있게 체인 형태로 구성한 것을 말한다. 중간 과정상의 함수를 실행한 결과는 그다음 인자를 받기 위해 대기만 할 뿐으로, 마지막 인자가 전달되기 전까지는 원본 함수가 실행되지 않는다. (부분 적용 함수는 여러 개의 인자를 전달할 수 있고, 실행 결과를 재실행할 때 원본 함수가 무조건 실행된다.)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> curry3 = <span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> func(a, b);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getMaxWith10 = curry3(<span class="built_in">Math</span>.max)(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(getMaxWith10(<span class="number">8</span>)); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(getMaxWith10(<span class="number">25</span>)); <span class="comment">// 25</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getMinWith10 = curry3(<span class="built_in">Math</span>.min)(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(getMinWith10(<span class="number">8</span>)); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">console</span>.log(getMinWith10(<span class="number">25</span>)); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>부분 적용 함수와 달리 커링 함수는 필요한 상황에 직접 만들어 쓰기 용이하다. 필요한 인자 개수만큼 함수를 만들어 계속 리턴해주다가 마지막에만 짠! 하고 조합해서 리턴해주면 되기 때문이다.</p>
<p>화살표 함수로 구현하면 커링 함수를 이해하기에 훨씬 수월하다.</p>
<p>커링 함수가 유용한 경우가 있다. 당장 필요한 정보만 받아서 전달하고 또 필요한 정보가 들어오면 전달하는 식으로 하면 결국 마지막 인자가 넘어갈 때까지 함수 실행을 미루는 셈이 된다. 이를 함수형 프로그래밍에서는 지연실행이라고 칭한다. 원하는 시점까지 지연시켰다가 실행하는 것이 요긴한 상황이라면 커링을 쓰기에 적합한 것이다. 혹은 프로젝트 내에서 자주 쓰이는 함수의 매개변수가 항상 비슷하고 일부만 바뀌는 경우에도 적절한 후보가 될 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getInformation = <span class="function"><span class="keyword">function</span>(<span class="params">baseUrl</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fetch(baseUrl + path + <span class="string">"/"</span> + id); <span class="comment">// 실제 서버에 정보 요청</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">var</span> getInformation = <span class="function"><span class="params">baseUrl</span> =&gt;</span> <span class="function"><span class="params">path</span> =&gt;</span> <span class="function"><span class="params">id</span> =&gt;</span> fetch(baseUrl + path + <span class="string">"/"</span> + id);</span><br></pre></td></tr></table></figure>

<p>HTML5의 fetch 함수는 url을 받아 해당 url에 HTTP 요청을 한다. 보통 REST API를 이용할 경우 baseUrl은 몇 개로 고정되지만 나머지 path나 id 값은 매우 많을 수 있다. 이런 상황에서 서버에 정보를 요청할 필요가 있을 때마다 매번 baseUrl부터 전부 기입해주기보다는 공통적인 요소는 먼저 기억시켜두고 특정한 값(id)만으로 서버 요청을 수행하는 함수를 만들어두는 편이 개발 효율성이나 가독성 측면에서 더 좋을 것이다.</p>
<hr>
<h3 id="4-정리"><a href="#4-정리" class="headerlink" title="4. 정리"></a>4. 정리</h3><p>클로저란 어떤 함수에서 선언한 변수를 참조하는 내부함수를 외부로 전달할 경우, 함수의 실행 컨텍스트가 종료된 후에도 해당 변수가 사라지지 않는 현상이다.</p>
<p>내부함수를 외부로 전달하는 방법에는 함수를 return하는 경우뿐 아니라 콜백으로 전달하는 경우도 포함된다.</p>
<p>클로저는 그 본질이 메모리를 계속 차지하는 개념이므로 더는 사용하지 않게 된 클로저에 대해서는 메모리를 차지하지 않도록 관리해줄 필요가 있다.</p>
<p>출처 : <a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId>=206513031" target="_blank" rel="noopener">코어 자바스크립트</a></p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">태그</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/Javascript/">Javascript</a> <a class="tag tag--primary tag--small t-link" href="/tags/클로저/">클로저</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/03/22/Javascript-프로토타입/"
                    data-tooltip="[Javascript] 프로토타입"
                    aria-label="이전: [Javascript] 프로토타입"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/03/08/Javascript-콜백-함수/"
                    data-tooltip="[Javascript] 콜백 함수"
                    aria-label="다음: [Javascript] 콜백 함수"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cok2exe.github.io/2020/03/15/Javascript-클로저/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cok2exe.github.io/2020/03/15/Javascript-클로저/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://cok2exe.github.io/2020/03/15/Javascript-클로저/"
                    title="Google+에 공유하기"
                    aria-label="Google+에 공유하기"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 dajyu. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/03/22/Javascript-프로토타입/"
                    data-tooltip="[Javascript] 프로토타입"
                    aria-label="이전: [Javascript] 프로토타입"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/03/08/Javascript-콜백-함수/"
                    data-tooltip="[Javascript] 콜백 함수"
                    aria-label="다음: [Javascript] 콜백 함수"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cok2exe.github.io/2020/03/15/Javascript-클로저/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cok2exe.github.io/2020/03/15/Javascript-클로저/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://cok2exe.github.io/2020/03/15/Javascript-클로저/"
                    title="Google+에 공유하기"
                    aria-label="Google+에 공유하기"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://cok2exe.github.io/2020/03/15/Javascript-클로저/"
                        aria-label="Facebook에 공유하기"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Facebook에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://cok2exe.github.io/2020/03/15/Javascript-클로저/"
                        aria-label="Twitter에 공유하기"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Twitter에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=https://cok2exe.github.io/2020/03/15/Javascript-클로저/"
                        aria-label="Google+에 공유하기"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Google+에 공유하기</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/over.jpg" alt="저자 이미지"/>
        
            <h4 id="about-card-name">dajyu</h4>
        
            <div id="about-card-bio"><p>혼잣말 공부러(코드사냥꾼)</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Web frontend</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Asia/Seoul
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->


    




    </body>
</html>
