
<!DOCTYPE html>
<html lang="ko">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="공부방">
    <title>[Javascript] 콜백 함수 - 공부방</title>
    <meta name="author" content="dajyu">
    
        <meta name="keywords" content="React,Typescript,HTML,CSS,Frontend,">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"dajyu","sameAs":["https://github.com/cok2exe","http://stackoverflow.com/cok2exe"],"image":"over.jpg"},"articleBody":"1. 콜백 함수란?콜백 함수는 다른 코드의 인자로 넘겨주는 함수를 말한다. 콜백 함수를 넘겨받은 코드는 이 콜백 함수를 필요에 따라 적절한 시점에 실행할 것이다.\n어떤 함수 X를 호출하면서 ‘특정 조건일 때 함수 Y를 실행해서 나에게 알려달라’는 요청을 함께 보내는 것이다.\n콜백 함수는 다른 코드(함수 또는 메서드)에게 인자로 넘겨줌으로써 그 제어권도 함께 위임한 함수이다. 콜백 함수를 위임받은 코드는 자체적인 내부 로직에 의해 이 콜백 함수를 적절한 시점에 실행할 것이다.\n\n\n\n2. 제어권몇 가지 예제를 통해 구체적으로 살펴보자.\n2-1. 호출 시점[예제 4-1] 콜백 함수 예제 (1-1) setInterval\n12345var count = 0;var timer = setInterval(function() &#123;  console.log(count);  if (++count &gt; 4) clearInterval(timer);&#125;, 300);\n\n1번째 줄에서 count 변수를 선언하고 0을 할당했다. 2번째 줄에서는 timer 변수를 선언하고 여기에 setInterval을 실행한 결과를 할당했다. setInterval을 호출할 때 두 개의 매개변수를 전달했는데, 그중 첫 번째는 익명 함수이고, 두 번째는 300이라는 숫자이다. setInterval의 구조를 살펴보면 다음과 같다.\n1var intervalID = scope.setInterval(func, delay[, param1, param2, ...]);\n\n우선 scope에는 window 객체 또는 Worker의 인스턴스가 들어올 수 있다. 두 객체 모두 setInterval 메서드를 제공하기 때문인데, 일반적인 브라우저 환경에서는 window를 생략해서 함수처럼 사용 가능할 것이다. 매개변수로는 func, delay 값을 반드시 전달해야 하고, 세 번째 매개변수부터는 선택적이다. func는 함수이고, delay는 밀리초(ms) 단위의 숫자이며, 나머지(param1, param2, …)는 func 함수를 실행할 때 매개변수로 전달할 인자이다. func에 넘겨준 함수는 매 delay(ms)마다 실행되며, 그 결과 어떠한 값도 리턴하지 않는다. setInterval를 실행하면 반복적으로 실행되는 내용 자체를 특정할 수 있는 고유한 ID 값이 반환된다. 이를 변수에 담는 이유는 반복 실행되는 중간에 종료(clearInterval)할 수 있게 하기 위해서이다.\n위의 예제를 좀 더 확인하기 쉽게 바꾸면 아래와 같다.\n[예제 4-2] 콜백 함수 예제 (1-2) setInterval\n12345678910111213var count = 0;var cbFunc = function() &#123;  console.log(count);  if (++count &gt; 4) clearInterval(timer);&#125;;var timer = setInterval(cbFunc, 300);// - 실행 결과 -// 0// 1// 2// 3// 4\n\ntimer 변수에는 setInterval의 ID 값이 담긴다. setInterval에 전달한 첫 번째 인자인 cbFunc 함수(이 함수가 곧 콜백 함수이다)는 0.3초마다 자동으로 실행될 것이다. 콜백 함수 내부에서는 count 값을 출력하고, count를 1만큼 증가시킨 다음, 그 값이 4보다 크면 반복 실행을 종료하라고 한다.\nsetInterval이라고 하는 ‘다른 코드’에 첫 번째 인자로서 cbFunc 함수를 넘겨주자 제어권을 넘겨받은 setInterval이 스스로의 판단에 따라 적절한 시점에 이 익명 함수를 실행했다. 이처럼 콜백 함수의 제어권을 넘겨받은 코드는 콜백 함수 호출 시점에 대한 제어권을 가진다.\n2-2. 인자[예제 4-3] 콜백 함수 예제 (2-1) Array.prototype.map\n12345678910var newArr = [10, 20, 30].map(function(currentValue, index) &#123;  console.log(currentValue, index);  return currentValue + 5;&#125;);console.log(newArr);// 10 0// 20 1// 30 2// [15, 25, 35]\n\n1번째 줄에서 newArr 변수를 선언하고 우항의 결과를 할당했다. 5번째 줄에서 그 결과를 확인하고자 한다. 1번째 줄의 우항은 배열 [10, 20, 30]에 map 메서드를 호출하고 있다. 이때 첫 번째 매개변수로 익명 함수를 전달한다. 우선 map 메서드가 어떤 방식으로 동작하는지를 알아야 5번째 줄의 결과를 예상할 수 있을 것이다. Array의 prototype에 담긴 map 메서드는 다음과 같은 구조로 이뤄져 있다.\n12Array.prototype.map(callback[, thisArg])callback: function(currentValue, index, array)\n\nmap 메서드는 첫 번재 인자로 callback 함수를 받고, 생략 가능한 두 번째 인자로 콜백 함수 내부에서 this로 인식할 대상을 특정할 수 있다. thisArg를 생략할 경우에는 일반적인 함수와 마찬가지로 전역객체가 바인딩된다. map 메서드는 메서드의 대상이 되는 배열의 모든 요소들을 처음부터 끝까지 하나씩 꺼내어 콜백 함수를 반복 호출하고, 콜백 함수의 실행 결과들을 모아 새로운 배열을 만든다. 콜백 함수의 첫 번째 인자에는 배열의 요소 중 현재값이, 두 번째 인자에는 현재값의 인덱스가, 세 번째 인자에는 map 메서드의 대상이 되는 배열 자체가 담긴다.\n이를 바탕으로 위의 예제를 다시 보면, 배열 [10, 20, 30]의 각 요소를 처음부터 하나씩 꺼내어 콜백 함수를 실행한다. 우선 첫 번째(인덱스 0)에 대한 콜백 함수는 currentValue에 10이, index에는 인덱스0이 담긴 채 실행될 것이다. 각 값을 출력한 다음, 15 (10 + 5)를 반환할 것이다. 두 번째, 세 번째 모두 마찬가지로 동작할 것이다.\n원하는 시각에 알람이 울리는 결과를 얻기 위해서는 시계가 정한 규칙, 즉 ‘알람용 침이 원하는 시각을 가리키도록 정하고 알람 스위치를 ON으로 설정해야 한다’라는 규칙을 따라야만 한다. 마찬가지로 map 메서드를 호출해서 원하는 배열을 얻으려면 map 메서드에 정의된 규칙에 따라 함수를 작성해야 한다. map 메서드에 정의된 규칙에는 콜백 함수의 인자로 넘어올 값들 및 그 순서도 포함돼 있다. 콜백 함수를 호출하는 주체가 사용자가 아닌 map 메서드이므로 map 메서드가 콜백 함수를 호출할 때 인자에 어떤 값들을 어떤 순서로 넘길 것인지가 전적으로 map 메서드에게 달린 것이다.\n\n이처럼 콜백 함수의 제어권을 넘겨받은 코드는 콜백 함수를 호출할 때 인자에 어떤 값들을 어떤 순서로 넘길 것인지에 대한 제어권을 가진다.\n\n2-3. this“콜백 함수도 함수이기 때문에 기본적으로는 this가 전역객체를 참조하지만, 제어권을 넘겨받을 코드에서 콜백 함수에 별도로 this가 될 대상을 지정한 경우에는 그 대상을 참조하게 된다.” 별도의 this를 지정하는 방식 및 제어권에 대한 이해를 위해 map 메서드를 직접 구현해 보자.\n[예제 4-5] 콜백 함수 예제 (2-3) Array.prototype.map - 구현\n12345678Array.prototype.map = function(callback, thisArg) &#123;  var mappedArr = [];  for (var i = 0; i &lt; this.length; i++) &#123;    var mappedValue = callback.call(thisArg || window, this[i], i, this);    mappedArr[i] = mappedValue;  &#125;  return mappedArr;&#125;;\n\n메서드 구현의 핵심은 call/apply 메서드에 있다. this에는 thisArg 값이 있을 경우에는 그 값을, 없을 경우에는 전역객체를 지정하고, 첫 번째 인자에는 메서드의 this가 배열을 가리킬 것이므로 배열의 i번째 요소 값을, 두 번째 인자에는 i 값을, 세 번째 인자에는 배열 자체를 지정해 호출한다. 그 결과가 변수 mappedValue에 담겨 mappedArr의 i번째 인자에 할당된다.\n이제 this에 다른 값이 담기는 이유를 정확히 알 수 있다. 바로 제어권을 넘겨받을 코드에서 call/apply 메서드의 첫 번째 인자에 콜백 함수 내부에서의 this가 될 대상을 명시적으로 바인딩하기 때문이다.\n[예제 4-6] 콜백 함수 내부에서의 this\n123456789101112setTimeout(function() &#123;  console.log(this);&#125;, 300); //(1) Window[1, 2, 3, 4, 5].forEach(function(x) &#123;  console.log(this); // (2) Window&#125;);document.body.innterHTML += '&lt;button id=\"a\"&gt;클릭&lt;/button&gt;';document.body.querySelector(\"#a\").addEventListener(\"click\", function(e) &#123;  console.log(this, e); // (3) &lt;button id=\"a\"&gt;클릭&lt;/button&gt;, MouseEvent&#125;);\n\n(1)과 (2)의 경우 this가 전역객체를 가리킨다. (2)는 ‘별도의 인자로 this를 받는 경우’에 해당하지만 별도의 인자로 this를 넘겨주지 않았기 때문에 전역객체를 가리키게 된다. (3)의 addEventListener는 내부에서 콜백 함수를 호출할 때 call 메서드의 첫 번째 인자에 addEventListener 메서드의 this를 그대로 넘기도록 정의돼 있기 때문에 콜백 함수 내부에서의 this가 addEventListener를 호출한 주체인 HTML 엘리먼트를 가리키게 된다.\n\n3. 콜백 함수는 함수다콜백 함수는 함수이다. 콜백 함수로 어떤 객체의 메서드를 전달하더라도 그 메서드는 메서드가 아닌 함수로서 호출된다.\n[예제 4-7] 메서드를 콜백 함수로 전달한 경우\n1234567891011var obj = &#123;  vals: [1, 2, 3],  logValues: function(v, i) &#123;    console.log(this, v, i);  &#125;&#125;;obj  .logValues(1, 2) // &#123; vals: [1, 2, 3], logValues: f &#125; 1 2  [(4, 5, 6)].forEach(obj.logValues); // Window &#123; ... &#125; 4 0// Window &#123; ... &#125; 5 0// Window &#123; ... &#125; 6 0\n\nobj 객체의 logValues는 메서드로 정의됐다. 7번째 줄에서는 이 메서드의 이름 앞에 점이 있으니 메서드로서 호출한 것이다. 따라서 this는 obj를 가리키고, 인자로 넘어온 1, 2가 출력된다.\n한편 8번째 줄에서는 이 메서드를 forEach 함수의 콜백 함수로서 전달했다. obj를 this로 하는 메서드를 그대로 전달한 것이 아니라, obj.logValues가 가리키는 함수만 전달한 것이다. 이 함수는 메서드로서 호출할 때가 아닌 한 obj와의 직접적인 연관이 없어진다. forEach에 의해 콜백이 함수로서 호출되고, 별도로 this를 지정하는 인자를 지정하지 않았으므로 함수 내부에서의 this는 전역객체를 바라보게 된다.\n그러니까 어떤 함수의 인자에 객체의 메서드를 전달하더라도 이는 결국 메서드가 아닌 함수일 뿐이다. 이 차이를 정확히 이해하는 것이 중요하다.\n\n4. 콜백 함수 내부의 this에 다른 값 바인딩하기객체의 메서드를 콜백 함수로 전달하면 해당 객체를 this로 바라볼 수 없게 된다는 점은 이제 이해했다. 그럼에도 콜백 함수 내부에서 this가 객체를 바라보게 하고 싶다면 어떻게 해야 할까? 별도의 인자로 this를 받는 함수의 경우에는 여기에 원하는 값을 넘겨주면 되지만 그렇지 않은 경우에는 this의 제어권도 넘겨주게 되므로 사용자가 임의로 값을 바꿀 수 없다. 그래서 전통적으로는 this를 다른 변수에 담아 콜백 함수로 활용할 함수에서는 this 대신 그 변수를 사용하게 하고, 이를 클로저로 만드는 방식이 많이 쓰였다.\n[예제 4-8] 콜백 함수 내부의 this에 다른 값을 바인딩하는 방법(1) - 전통적인 방식\n1234567891011var obj1 = &#123;  name: \"obj1\",  func: function() &#123;    var self = this;    return function() &#123;      console.log(self.name);    &#125;;  &#125;&#125;;var callback = obj1.func();setTimeout(callback, 1000);\n\nobj1.func 메서드 내부에서 self 변수에 this를 담고, 익명 함수를 선언과 동시에 반환했다. 이제 10번째 줄에서 obj1.func 를 호출하면 앞서 선언한 내부함수가 반환되어 callback 변수에 담긴다. 11번째 줄에서 이 callback을 setTimeout 함수에 인자로 전달하면 1초 뒤 callback이 실행되면서 ‘obj1’을 출력할 것이다.\n이 방식은 실제로 this를 사용하지도 않을뿐더러 번거롭기 그지 없다. 차라리 this를 아예 안 쓰는 편이 더 낫겠다는 생각이 든다.\n[예제 4-9] 콜백 함수 내부에서 this를 사용하지 않은 경우\n1234567var obj1 = &#123;  name: \"obj1\",  func: function() &#123;    console.log(obj1.name);  &#125;&#125;;setTimeout(obj1.func, 1000);\n\n[예제 4-9]는 [예제 4-8]에서 this를 사용하지 않았을 때의 결과이다. 훨씬 간결하고 직관적이지만 아쉬운 부분도 있다. 이제는 작성한 함수를 this를 이용해 다양한 상황에 재활용할 수 없게 되어버렸다. [예제 4-8]에서 만들었던 함수를 다른 객체에 재활용하는 상황을 살펴보자.\n[예제 4-10] 예제 4-8의 func 함수 재활용\n1234567891011// ...var obj2 = &#123;  name: \"obj2\",  func: obj1.func&#125;;var callback2 = obj2.func();setTimeout(callback2, 1500);var obj3 = &#123; name: \"obj3\" &#125;;var callback3 = obj1.func.call(obj3);setTimeout(callback3, 2000);\n\n[예제 4-10]의 callback2에는 (obj1의 func를 복사한) obj2의 func를 실행한 결과를 담아 이를 콜백으로 사용했다. callback3의 경우 obj1의 func를 실행하면서 this를 obj3가 되도록 지정해 이를 콜백으로 사용했다. 예제를 실행해보면 실행 시점으로 1.5초 후에는 ‘obj2’가, 실행 시점으로부터 2초 후에는 ‘obj3’이 출력된다. 이처럼 [예제 4-8]의 방법은 번거롭긴 하지만 this를 우회적으로나마 활용함으로써 다양한 상황에서 원하는 객체를 바라보는 콜백 함수를 만들 수 있는 방법이다.\n반면 [예제 4-9]의 경우는 처음부터 바라볼 객체를 명시적으로 obj1로 지정했기 때문에 어떤 방법으로도 다른 객체를 바라보게끔 할 수가 없다. 이런 문제점 때문에 불편할 뿐 아니라 메모리를 낭비하는 측면이 있음에도 [예제 4-8]과 같은 전통적인 방식이 널리 통용될 수밖에 없었던 측면도 있다. 재활용이 필요없는 부분에는 [예제 4-9]와 같이 해도 아무런 문제가 없다. 상황에 따라 적절한 방식을 취해야 한다.\n다행히 이제는 전통적인 방식의 아쉬움을 보완하는 훌륭한 방법이 있다. 바로 ES5에서 등장한 bind 메서드를 이용하는 방법이다.\n[예제 4-11] 콜백 함수 내부의 this에 다른 값을 바인딩하는 방법(2) - bind 메서드 활용\n12345678910var obj1 = &#123;  name: \"obj1\",  func: function() &#123;    console.log(this.name);  &#125;&#125;;setTimeout(obj1.func.bind(obj1), 1000);var obj2 = &#123; name: \"obj2\" &#125;;setTimeout(obj1.func.bind(obj2), 1500);\n\n\n5. 콜백 지옥과 비동기 제어콜백 지옥은 콜백 함수를 익명 함수로 전달하는 과정이 반복되어 코드의 들여쓰기 수준이 감당하기 힘들 정도로 깊어지는 현상으로, 자바스크립트에서 흔히 발생하는 문제이다. 주로 이벤트 처리나 서버 통신과 같이 비동기적인 작업을 수행하기 위해 이런 형태가 자주 등장하곤 하는데, 가독성이 떨어질뿐더러 코드를 수정하기도 어렵다.\n비동기는 동기의 반대말이다. 동기적인 코드는 현재 실행 중인 코드가 완료된 후에야 다음 코드를 실행하는 방식이다. 반대로 비동기적인 코드는 현재 실행 중인 코드의 완료 여부와 무관하게 즉시 다음 코드로 넘어간다. CPU의 계산에 의해 즉시 처리가 가능한 대부분의 코드는 동기적인 코드이다. 계산식이 복잡해서 CPU가 계산하는 데 시간이 많이 필요한 경우라 하더라도 이는 동기적인 코드이다. 반면 사용자의 요청에 의해 특정 시간이 경과되기 전까지 어떤 함수의 실행을 보류한다거나(setTimeout), 사용자의 직접적인 개입이 있을 때 비로소 어떤 함수를 실행하도록 대기한다거나(addEventListener), 웹브라우저 자체가 아닌 별도의 대상에 무언가를 요청하고 그에 대한 응답이 왔을 때 비로소 어떤 함수를 실행하도록 대기하는 등(XMLHttpRequest), 별도의 요청, 실행 대기, 보류 등과 관련된 코드는 비동기적인 코드이다.\n그런데 현대의 자바스크립트는 웹의 복잡도가 높아진 만큼 비동기적인 코드의 비중이 예전보다 훨씬 높아진 상황이다. 그와 동시에 콜백 지옥에 빠지기도 훨씬 쉬워진 셈이다.\n[예제 4-12] 콜백 지옥 예시 (1-1)\n12345678910111213141516171819setTimeout(function (name) &#123;  var coffeeList = name;  console.log(coffeeList)  setTimeout(function (name)) &#123;    coffeeList += ', ' + name;    console.log(coffeeList)    setTimeout(function (name)) &#123;      coffeeList += ', ' + name;      console.log(coffeeList)      setTimeout(function (name)) &#123;        coffeeList += ', ' + name;        console.log(coffeeList)      &#125;, 500, '카페라떼')    &#125;, 500, '카페모카')  &#125;, 500, '아메리카노')&#125;, 500, '에스프레소')\n\n[예제 4-12]는 0.5초 주기마다 커피 목록을 수집하고 출력한다. 각 콜백은 커피 이름을 전달하고 목록에 이름을 추가한다. 목적 달성에는 지장이 없지만 들여쓰기 수준이 과도하게 깊어졌을뿐더러 값이 전달되는 순서가 ‘아래에서 위로’ 향하고 있어 어색하게 느껴질 것이다.\n가독성 문제와 어색함을 동시에 해결하는 가장 간단한(?) 방법은 익명의 콜백 함수를 모두 기명함수로 전환하는 것이다.\n[예제 4-13] 콜백 지옥 해결 - 기명함수로 변환\n1234567891011121314151617181920212223var coffeeList = \"\";var addEspresso = function(name) &#123;  coffeeList = name;  console.log(coffeeList);  setTimeout(addAmericano, 500, \"아메리카노\");&#125;;var addAmericano = function(name) &#123;  coffeeList += \", \" + name;  console.log(coffeeList);  setTimeout(addMocha, 500, \"카페모카\");&#125;;var addMocha = function(name) &#123;  coffeeList += \", \" + name;  console.log(coffeeList);  setTimeout(addLatte, 500, \"카페라떼\");&#125;;var addLatte = function(name) &#123;  coffeeList += \", \" + name;  console.log(coffeeList);&#125;;setTimeout(addEspresso, 500, \"에스프레소\");\n\n이 방식은 코드의 가독성을 높일뿐 아니라 함수 선언과 함수 호출만 구분할 수 있다면 위에서부터 아래로 순서대로 읽어내려가는 데 어려움이 없다. 또한 변수를 최상단으로 끌어올림으로써 외부에 노출되게 됐지만 전체를 즉시 실행 함수 등으로 감싸면 간단히 해결될 문제이다.\n지난 십수 년간 자바스크립트는 비동기적인 일련의 작업을 동기적으로, 혹은 동기적인 것처럼 보이게끔 처리해주는 장치를 마련하고자 끊임없이 노력했다. ES6에서는 Promise, Generator 등이 도입됐고, ES2017에서는 async/await가 도입됐다. 이들을 이용해 위 코드를 수정한 내용을 각각 간략하게 소개한다.\n[예제 4-14] 비동기 작업의 동기적 표현(1) - Promise(1)\n12345678910111213141516171819202122232425262728293031323334new Promise(function(resolve) &#123;  setTimeout(function() &#123;    var name = \"에스프레소\";    console.log(name);    resolve(name);  &#125;, 500);&#125;)  .then(function(prevName) &#123;    return new Promise(function(resolve) &#123;      setTimeout(function() &#123;        var name = prevName + \", 아메리카노\";        console.log(name);        resolve(name);      &#125;, 500);    &#125;);  &#125;)  .then(function(prevName) &#123;    return new Promise(function(resolve) &#123;      setTimeout(function() &#123;        var name = prevName + \", 카페모카\";        console.log(name);        resolve(name);      &#125;, 500);    &#125;);  &#125;)  .then(function(prevName) &#123;    return new Promise(function(resolve) &#123;      setTimeout(function() &#123;        var name = prevName + \", 카페라떼\";        console.log(name);        resolve(name);      &#125;, 500);    &#125;);  &#125;);\n\n첫 번째로 ES6의 Promise를 이용한 방식이다. new 연산자와 함께 호출한 Promise의 인자로 넘겨주는 콜백 함수는 호출할 때 바로 실행되지만 그 내부에 resolve 또는 reject 함수를 호출하는 구문이 있을 경우 둘 중 하나가 실행되기 전까지는 다음(then) 또는 오류 구문(catch)으로 넘어가지 않는다. 따라서 비동기 작업이 완료될 때 비로소 resolve 또는 reject를 호출하는 방법으로 비동기 작업의 동기적 표현이 가능하다.\n[예제 4-15] 비동기 작업의 동기적 표현(2) - Promise(2)\n123456789101112131415var addCoffee = function(name) &#123;  return function(prevName) &#123;    return new Promise(function(resolve) &#123;      setTimeout(function() &#123;        var newName = prevName ? prevName + \", \" + name : name;        console.log(newName);        resolve(newName);      &#125;, 500);    &#125;);  &#125;;&#125;;addCoffee(\"에스프레소\")()  .then(addCoffee(\"아메리카노\"))  .then(addCoffee(\"카페모카\"))  .then(addCoffee(\"카페라떼\"));\n\n[예제 4-15]는 [예제 4-14]의 반복적인 내용을 함수화해서 더욱 짧게 표현한 것이다.\n[예제 4-16] 비동기 작업의 동기적 표현(3) - Generator\n1234567891011121314151617var addCoffee = function(prevName, name) &#123;  setTimeout(function() &#123;    coffeeMaker.next(prevName ? prevName + \", \" + name : name);  &#125;, 500);&#125;;var coffeeGenerator = function*() &#123;  var espresso = yield addCoffee(\"\", \"에스프레소\");  console.log(espresso);  var americano = yield addCoffee(espresso, \"아메리카노\");  console.log(americano);  var mocha = yield addCoffee(americano, \"카페모카\");  console.log(mocha);  var latte = yield addCoffee(mocha, \"카페라떼\");  console.log(latte);&#125;;var coffeeMaker = coffeeGenerator();coffeeMaker.next();\n\n[예제 4-16]은 ES6의 Generator를 이용했다. 6번째 줄의 *이 붙은 함수가 바로 Generator 함수이다. Generator 함수를 실행하면 Iterator가 반환되는데, Iterator는 next라는 메서드를 가지고 있다. 이 next 메서드를 호출하면 Generator 함수 내부에서 가장 먼저 등장하는 yield에서 함수의 실행을 멈춘다. 이후 다시 next 메서드를 호출하면 앞서 멈췄던 부분부터 시작해서 그다음에 등장하는 yield에서 함수의 실행을 멈춘다. 그러니까 비동기 작업이 완료되는 시점마다 next 메서드를 호출해준다면 Generator 함수 내부의 소스가 위에서부터 아래로 순차적으로 진행된다.\n[예제 4-17] 비동기 작업의 동기적 표현(4) - Promise + Async/await\n12345678910111213141516171819202122var addCoffee = function(name) &#123;  return new Promise(function(resolve) &#123;    setTimeout(function() &#123;      resolve(name);    &#125;, 500);  &#125;);&#125;;var coffeeMaker = async function() &#123;  var coffeeList = \"\";  var _addCoffee = async function(name) &#123;    coffeeList += (coffeeList ? \",\" : \"\") + (await addCoffee(name));  &#125;;  await _addCoffee(\"에스프레소\");  console.log(coffeeList);  await _addCoffee(\"아메리카노\");  console.log(coffeeList);  await _addCoffee(\"카페모카\");  console.log(coffeeList);  await _addCoffee(\"카페라떼\");  console.log(coffeeList);&#125;;coffeeMaker();\n\n한편 ES2017에서는 가독성이 뛰어나면서도 작성법도 간단한 새로운 기능이 추가됐는데, 바로 async/await 이다. 비동기 작업을 수행하고자 하는 함수 앞에 async를 표기하고, 함수 내부에서 실질적인 비동기 작업이 필요한 위치마다 await를 표기하는 것만으로로 뒤의 내용을 Promise로 자동 전환하고, 해당 내용이 resolve된 이후에야 다음으로 진행된다. 즉 Promise의 then과 흡사한 효과를 얻을 수 있다.\n\n6. 정리\n콜백 함수는 다른 코드에 인자로 넘겨줌으로써 그 제어권도 함께 위임한 함수이다\n제어권을 넘겨받은 코드는 다음과 같은 제어권을 가진다.\n\n\n콜백 함수를 호출하는 시점을 스스로 판단해서 실행한다.\n콜백 함수를 호출할 때 인자로 넘겨줄 값들 및 그 순서가 정해져 있다. 이 순서를 따르지 않고 코드를 작성하면 엉뚱한 결과를 얻게 된다.\n콜백 함수의 this가 무엇을 바라보도록 할지가 정해져 있는 경우도 있다. 정하지 않은 경우에는 전역객체를 바라본다. 사용자 임의로 this를 바꾸고 싶을 경우 bind 메서드를 활용하면 된다.\n\n\n어떤 함수에 인자로 메서드를 전달하더라도 이는 결국 함수로서 실행된다.\n비동기 제어를 위해 콜백 함수를 사용하다 보면 콜백 지옥에 빠지기 쉽다. 최근의 ECMAScript에는 Promise, Generator, async/await 등 콜백 지옥에서 벗어날 수 있는 훌륭한 방법들이 속속 등장하고 있다.\n\n출처 : 코어 자바스크립트\n","dateCreated":"2020-03-08T16:11:39+09:00","dateModified":"2020-03-15T10:20:50+09:00","datePublished":"2020-03-08T16:11:39+09:00","description":"1. 콜백 함수란?콜백 함수는 다른 코드의 인자로 넘겨주는 함수를 말한다. 콜백 함수를 넘겨받은 코드는 이 콜백 함수를 필요에 따라 적절한 시점에 실행할 것이다.\n어떤 함수 X를 호출하면서 ‘특정 조건일 때 함수 Y를 실행해서 나에게 알려달라’는 요청을 함께 보내는 것이다.\n콜백 함수는 다른 코드(함수 또는 메서드)에게 인자로 넘겨줌으로써 그 제어권도 함께 위임한 함수이다. 콜백 함수를 위임받은 코드는 자체적인 내부 로직에 의해 이 콜백 함수를 적절한 시점에 실행할 것이다.","headline":"[Javascript] 콜백 함수","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://cok2exe.github.io/2020/03/08/Javascript-콜백-함수/"},"publisher":{"@type":"Organization","name":"dajyu","sameAs":["https://github.com/cok2exe","http://stackoverflow.com/cok2exe"],"image":"over.jpg","logo":{"@type":"ImageObject","url":"over.jpg"}},"url":"https://cok2exe.github.io/2020/03/08/Javascript-콜백-함수/","keywords":"Javascript, 콜백 함수"}</script>
    <meta name="description" content="1. 콜백 함수란?콜백 함수는 다른 코드의 인자로 넘겨주는 함수를 말한다. 콜백 함수를 넘겨받은 코드는 이 콜백 함수를 필요에 따라 적절한 시점에 실행할 것이다. 어떤 함수 X를 호출하면서 ‘특정 조건일 때 함수 Y를 실행해서 나에게 알려달라’는 요청을 함께 보내는 것이다. 콜백 함수는 다른 코드(함수 또는 메서드)에게 인자로 넘겨줌으로써 그 제어권도 함께">
<meta name="keywords" content="Javascript,콜백 함수">
<meta property="og:type" content="blog">
<meta property="og:title" content="[Javascript] 콜백 함수">
<meta property="og:url" content="https://cok2exe.github.io/2020/03/08/Javascript-콜백-함수/index.html">
<meta property="og:site_name" content="공부방">
<meta property="og:description" content="1. 콜백 함수란?콜백 함수는 다른 코드의 인자로 넘겨주는 함수를 말한다. 콜백 함수를 넘겨받은 코드는 이 콜백 함수를 필요에 따라 적절한 시점에 실행할 것이다. 어떤 함수 X를 호출하면서 ‘특정 조건일 때 함수 Y를 실행해서 나에게 알려달라’는 요청을 함께 보내는 것이다. 콜백 함수는 다른 코드(함수 또는 메서드)에게 인자로 넘겨줌으로써 그 제어권도 함께">
<meta property="og:locale" content="ko">
<meta property="og:updated_time" content="2020-03-15T01:20:50.514Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[Javascript] 콜백 함수">
<meta name="twitter:description" content="1. 콜백 함수란?콜백 함수는 다른 코드의 인자로 넘겨주는 함수를 말한다. 콜백 함수를 넘겨받은 코드는 이 콜백 함수를 필요에 따라 적절한 시점에 실행할 것이다. 어떤 함수 X를 호출하면서 ‘특정 조건일 때 함수 Y를 실행해서 나에게 알려달라’는 요청을 함께 보내는 것이다. 콜백 함수는 다른 코드(함수 또는 메서드)에게 인자로 넘겨줌으로써 그 제어권도 함께">
    
    
        
    
    
        <meta property="og:image" content="https://cok2exe.github.io/assets/images/over.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            공부방
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="링크 열기: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/over.jpg" alt="저자 이미지"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="저자에 대해 더 알아보기"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/over.jpg" alt="저자 이미지"/>
                </a>
                <h4 class="sidebar-profile-name">dajyu</h4>
                
                    <h5 class="sidebar-profile-bio"><p>혼잣말 공부러(코드사냥꾼)</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="Home"
                        >
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                            title="About"
                        >
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/cok2exe" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="http://stackoverflow.com/cok2exe" target="_blank" rel="noopener" title="Stack Overflow">
                    
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            [Javascript] 콜백 함수
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2020-03-08T16:11:39+09:00">
	
		    2020/03/08
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/Javascript/">Javascript</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <h3 id="1-콜백-함수란"><a href="#1-콜백-함수란" class="headerlink" title="1. 콜백 함수란?"></a>1. 콜백 함수란?</h3><p>콜백 함수는 다른 코드의 인자로 넘겨주는 함수를 말한다. 콜백 함수를 넘겨받은 코드는 이 콜백 함수를 필요에 따라 적절한 시점에 실행할 것이다.</p>
<p>어떤 함수 X를 호출하면서 ‘특정 조건일 때 함수 Y를 실행해서 나에게 알려달라’는 요청을 함께 보내는 것이다.</p>
<p>콜백 함수는 다른 코드(함수 또는 메서드)에게 인자로 넘겨줌으로써 그 제어권도 함께 위임한 함수이다. 콜백 함수를 위임받은 코드는 자체적인 내부 로직에 의해 이 콜백 함수를 적절한 시점에 실행할 것이다.</p>
<a id="more"></a>

<hr>
<h3 id="2-제어권"><a href="#2-제어권" class="headerlink" title="2. 제어권"></a>2. 제어권</h3><p>몇 가지 예제를 통해 구체적으로 살펴보자.</p>
<h4 id="2-1-호출-시점"><a href="#2-1-호출-시점" class="headerlink" title="2-1. 호출 시점"></a>2-1. 호출 시점</h4><p>[예제 4-1] 콜백 함수 예제 (1-1) setInterval</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count);</span><br><span class="line">  <span class="keyword">if</span> (++count &gt; <span class="number">4</span>) clearInterval(timer);</span><br><span class="line">&#125;, <span class="number">300</span>);</span><br></pre></td></tr></table></figure>

<p>1번째 줄에서 count 변수를 선언하고 0을 할당했다. 2번째 줄에서는 timer 변수를 선언하고 여기에 setInterval을 실행한 결과를 할당했다. setInterval을 호출할 때 두 개의 매개변수를 전달했는데, 그중 첫 번째는 익명 함수이고, 두 번째는 300이라는 숫자이다. setInterval의 구조를 살펴보면 다음과 같다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intervalID = scope.setInterval(func, delay[, param1, param2, ...]);</span><br></pre></td></tr></table></figure>

<p>우선 scope에는 window 객체 또는 Worker의 인스턴스가 들어올 수 있다. 두 객체 모두 setInterval 메서드를 제공하기 때문인데, 일반적인 브라우저 환경에서는 window를 생략해서 함수처럼 사용 가능할 것이다. 매개변수로는 func, delay 값을 반드시 전달해야 하고, 세 번째 매개변수부터는 선택적이다. func는 함수이고, delay는 밀리초(ms) 단위의 숫자이며, 나머지(param1, param2, …)는 func 함수를 실행할 때 매개변수로 전달할 인자이다. func에 넘겨준 함수는 매 delay(ms)마다 실행되며, 그 결과 어떠한 값도 리턴하지 않는다. setInterval를 실행하면 반복적으로 실행되는 내용 자체를 특정할 수 있는 고유한 ID 값이 반환된다. 이를 변수에 담는 이유는 반복 실행되는 중간에 종료(clearInterval)할 수 있게 하기 위해서이다.</p>
<p>위의 예제를 좀 더 확인하기 쉽게 바꾸면 아래와 같다.</p>
<p>[예제 4-2] 콜백 함수 예제 (1-2) setInterval</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> cbFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count);</span><br><span class="line">  <span class="keyword">if</span> (++count &gt; <span class="number">4</span>) clearInterval(timer);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> timer = setInterval(cbFunc, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// - 실행 결과 -</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>timer 변수에는 setInterval의 ID 값이 담긴다. setInterval에 전달한 첫 번째 인자인 cbFunc 함수(이 함수가 곧 콜백 함수이다)는 0.3초마다 자동으로 실행될 것이다. 콜백 함수 내부에서는 count 값을 출력하고, count를 1만큼 증가시킨 다음, 그 값이 4보다 크면 반복 실행을 종료하라고 한다.</p>
<p>setInterval이라고 하는 ‘다른 코드’에 첫 번째 인자로서 cbFunc 함수를 넘겨주자 제어권을 넘겨받은 setInterval이 스스로의 판단에 따라 적절한 시점에 이 익명 함수를 실행했다. 이처럼 콜백 함수의 제어권을 넘겨받은 코드는 콜백 함수 호출 시점에 대한 제어권을 가진다.</p>
<h4 id="2-2-인자"><a href="#2-2-인자" class="headerlink" title="2-2. 인자"></a>2-2. 인자</h4><p>[예제 4-3] 콜백 함수 예제 (2-1) Array.prototype.map</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newArr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(currentValue, index);</span><br><span class="line">  <span class="keyword">return</span> currentValue + <span class="number">5</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(newArr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10 0</span></span><br><span class="line"><span class="comment">// 20 1</span></span><br><span class="line"><span class="comment">// 30 2</span></span><br><span class="line"><span class="comment">// [15, 25, 35]</span></span><br></pre></td></tr></table></figure>

<p>1번째 줄에서 newArr 변수를 선언하고 우항의 결과를 할당했다. 5번째 줄에서 그 결과를 확인하고자 한다. 1번째 줄의 우항은 배열 [10, 20, 30]에 map 메서드를 호출하고 있다. 이때 첫 번째 매개변수로 익명 함수를 전달한다. 우선 map 메서드가 어떤 방식으로 동작하는지를 알아야 5번째 줄의 결과를 예상할 수 있을 것이다. Array의 prototype에 담긴 map 메서드는 다음과 같은 구조로 이뤄져 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.map(callback[, thisArg])</span><br><span class="line">callback: <span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, array</span>)</span></span><br></pre></td></tr></table></figure>

<p>map 메서드는 첫 번재 인자로 callback 함수를 받고, 생략 가능한 두 번째 인자로 콜백 함수 내부에서 this로 인식할 대상을 특정할 수 있다. thisArg를 생략할 경우에는 일반적인 함수와 마찬가지로 전역객체가 바인딩된다. map 메서드는 메서드의 대상이 되는 배열의 모든 요소들을 처음부터 끝까지 하나씩 꺼내어 콜백 함수를 반복 호출하고, 콜백 함수의 실행 결과들을 모아 새로운 배열을 만든다. 콜백 함수의 첫 번째 인자에는 배열의 요소 중 현재값이, 두 번째 인자에는 현재값의 인덱스가, 세 번째 인자에는 map 메서드의 대상이 되는 배열 자체가 담긴다.</p>
<p>이를 바탕으로 위의 예제를 다시 보면, 배열 [10, 20, 30]의 각 요소를 처음부터 하나씩 꺼내어 콜백 함수를 실행한다. 우선 첫 번째(인덱스 0)에 대한 콜백 함수는 currentValue에 10이, index에는 인덱스0이 담긴 채 실행될 것이다. 각 값을 출력한 다음, 15 (10 + 5)를 반환할 것이다. 두 번째, 세 번째 모두 마찬가지로 동작할 것이다.</p>
<p>원하는 시각에 알람이 울리는 결과를 얻기 위해서는 시계가 정한 규칙, 즉 ‘알람용 침이 원하는 시각을 가리키도록 정하고 알람 스위치를 ON으로 설정해야 한다’라는 규칙을 따라야만 한다. 마찬가지로 map 메서드를 호출해서 원하는 배열을 얻으려면 map 메서드에 정의된 규칙에 따라 함수를 작성해야 한다. map 메서드에 정의된 규칙에는 콜백 함수의 인자로 넘어올 값들 및 그 순서도 포함돼 있다. 콜백 함수를 호출하는 주체가 사용자가 아닌 map 메서드이므로 map 메서드가 콜백 함수를 호출할 때 인자에 어떤 값들을 어떤 순서로 넘길 것인지가 전적으로 map 메서드에게 달린 것이다.</p>
<blockquote>
<p>이처럼 콜백 함수의 제어권을 넘겨받은 코드는 콜백 함수를 호출할 때 인자에 어떤 값들을 어떤 순서로 넘길 것인지에 대한 제어권을 가진다.</p>
</blockquote>
<h4 id="2-3-this"><a href="#2-3-this" class="headerlink" title="2-3. this"></a>2-3. this</h4><p>“콜백 함수도 함수이기 때문에 기본적으로는 this가 전역객체를 참조하지만, 제어권을 넘겨받을 코드에서 콜백 함수에 별도로 this가 될 대상을 지정한 경우에는 그 대상을 참조하게 된다.” 별도의 this를 지정하는 방식 및 제어권에 대한 이해를 위해 map 메서드를 직접 구현해 보자.</p>
<p>[예제 4-5] 콜백 함수 예제 (2-3) Array.prototype.map - 구현</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.map = <span class="function"><span class="keyword">function</span>(<span class="params">callback, thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> mappedArr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> mappedValue = callback.call(thisArg || <span class="built_in">window</span>, <span class="keyword">this</span>[i], i, <span class="keyword">this</span>);</span><br><span class="line">    mappedArr[i] = mappedValue;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mappedArr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>메서드 구현의 핵심은 call/apply 메서드에 있다. this에는 thisArg 값이 있을 경우에는 그 값을, 없을 경우에는 전역객체를 지정하고, 첫 번째 인자에는 메서드의 this가 배열을 가리킬 것이므로 배열의 i번째 요소 값을, 두 번째 인자에는 i 값을, 세 번째 인자에는 배열 자체를 지정해 호출한다. 그 결과가 변수 mappedValue에 담겨 mappedArr의 i번째 인자에 할당된다.</p>
<p>이제 this에 다른 값이 담기는 이유를 정확히 알 수 있다. 바로 제어권을 넘겨받을 코드에서 call/apply 메서드의 첫 번째 인자에 콜백 함수 내부에서의 this가 될 대상을 명시적으로 바인딩하기 때문이다.</p>
<p>[예제 4-6] 콜백 함수 내부에서의 this</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;, <span class="number">300</span>); <span class="comment">//(1) Window</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// (2) Window</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.innterHTML += <span class="string">'&lt;button id="a"&gt;클릭&lt;/button&gt;'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.querySelector(<span class="string">"#a"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>, e); <span class="comment">// (3) &lt;button id="a"&gt;클릭&lt;/button&gt;, MouseEvent</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>(1)과 (2)의 경우 this가 전역객체를 가리킨다. (2)는 ‘별도의 인자로 this를 받는 경우’에 해당하지만 별도의 인자로 this를 넘겨주지 않았기 때문에 전역객체를 가리키게 된다. (3)의 addEventListener는 내부에서 콜백 함수를 호출할 때 call 메서드의 첫 번째 인자에 addEventListener 메서드의 this를 그대로 넘기도록 정의돼 있기 때문에 콜백 함수 내부에서의 this가 addEventListener를 호출한 주체인 HTML 엘리먼트를 가리키게 된다.</p>
<hr>
<h3 id="3-콜백-함수는-함수다"><a href="#3-콜백-함수는-함수다" class="headerlink" title="3. 콜백 함수는 함수다"></a>3. 콜백 함수는 함수다</h3><p>콜백 함수는 함수이다. 콜백 함수로 어떤 객체의 메서드를 전달하더라도 그 메서드는 메서드가 아닌 함수로서 호출된다.</p>
<p>[예제 4-7] 메서드를 콜백 함수로 전달한 경우</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  vals: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  logValues: <span class="function"><span class="keyword">function</span>(<span class="params">v, i</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>, v, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj</span><br><span class="line">  .logValues(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// &#123; vals: [1, 2, 3], logValues: f &#125; 1 2</span></span><br><span class="line">  [(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)].forEach(obj.logValues); <span class="comment">// Window &#123; ... &#125; 4 0</span></span><br><span class="line"><span class="comment">// Window &#123; ... &#125; 5 0</span></span><br><span class="line"><span class="comment">// Window &#123; ... &#125; 6 0</span></span><br></pre></td></tr></table></figure>

<p>obj 객체의 logValues는 메서드로 정의됐다. 7번째 줄에서는 이 메서드의 이름 앞에 점이 있으니 메서드로서 호출한 것이다. 따라서 this는 obj를 가리키고, 인자로 넘어온 1, 2가 출력된다.</p>
<p>한편 8번째 줄에서는 이 메서드를 forEach 함수의 콜백 함수로서 전달했다. obj를 this로 하는 메서드를 그대로 전달한 것이 아니라, obj.logValues가 가리키는 함수만 전달한 것이다. 이 함수는 메서드로서 호출할 때가 아닌 한 obj와의 직접적인 연관이 없어진다. forEach에 의해 콜백이 함수로서 호출되고, 별도로 this를 지정하는 인자를 지정하지 않았으므로 함수 내부에서의 this는 전역객체를 바라보게 된다.</p>
<p>그러니까 어떤 함수의 인자에 객체의 메서드를 전달하더라도 이는 결국 메서드가 아닌 함수일 뿐이다. 이 차이를 정확히 이해하는 것이 중요하다.</p>
<hr>
<h3 id="4-콜백-함수-내부의-this에-다른-값-바인딩하기"><a href="#4-콜백-함수-내부의-this에-다른-값-바인딩하기" class="headerlink" title="4. 콜백 함수 내부의 this에 다른 값 바인딩하기"></a>4. 콜백 함수 내부의 this에 다른 값 바인딩하기</h3><p>객체의 메서드를 콜백 함수로 전달하면 해당 객체를 this로 바라볼 수 없게 된다는 점은 이제 이해했다. 그럼에도 콜백 함수 내부에서 this가 객체를 바라보게 하고 싶다면 어떻게 해야 할까? 별도의 인자로 this를 받는 함수의 경우에는 여기에 원하는 값을 넘겨주면 되지만 그렇지 않은 경우에는 this의 제어권도 넘겨주게 되므로 사용자가 임의로 값을 바꿀 수 없다. 그래서 전통적으로는 this를 다른 변수에 담아 콜백 함수로 활용할 함수에서는 this 대신 그 변수를 사용하게 하고, 이를 클로저로 만드는 방식이 많이 쓰였다.</p>
<p>[예제 4-8] 콜백 함수 내부의 this에 다른 값을 바인딩하는 방법(1) - 전통적인 방식</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">"obj1"</span>,</span><br><span class="line">  func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(self.name);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> callback = obj1.func();</span><br><span class="line">setTimeout(callback, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>obj1.func 메서드 내부에서 self 변수에 this를 담고, 익명 함수를 선언과 동시에 반환했다. 이제 10번째 줄에서 obj1.func 를 호출하면 앞서 선언한 내부함수가 반환되어 callback 변수에 담긴다. 11번째 줄에서 이 callback을 setTimeout 함수에 인자로 전달하면 1초 뒤 callback이 실행되면서 ‘obj1’을 출력할 것이다.</p>
<p>이 방식은 실제로 this를 사용하지도 않을뿐더러 번거롭기 그지 없다. 차라리 this를 아예 안 쓰는 편이 더 낫겠다는 생각이 든다.</p>
<p>[예제 4-9] 콜백 함수 내부에서 this를 사용하지 않은 경우</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">"obj1"</span>,</span><br><span class="line">  func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj1.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">setTimeout(obj1.func, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>[예제 4-9]는 [예제 4-8]에서 this를 사용하지 않았을 때의 결과이다. 훨씬 간결하고 직관적이지만 아쉬운 부분도 있다. 이제는 작성한 함수를 this를 이용해 다양한 상황에 재활용할 수 없게 되어버렸다. [예제 4-8]에서 만들었던 함수를 다른 객체에 재활용하는 상황을 살펴보자.</p>
<p>[예제 4-10] 예제 4-8의 func 함수 재활용</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  name: <span class="string">"obj2"</span>,</span><br><span class="line">  func: obj1.func</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> callback2 = obj2.func();</span><br><span class="line">setTimeout(callback2, <span class="number">1500</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj3 = &#123; <span class="attr">name</span>: <span class="string">"obj3"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> callback3 = obj1.func.call(obj3);</span><br><span class="line">setTimeout(callback3, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<p>[예제 4-10]의 callback2에는 (obj1의 func를 복사한) obj2의 func를 실행한 결과를 담아 이를 콜백으로 사용했다. callback3의 경우 obj1의 func를 실행하면서 this를 obj3가 되도록 지정해 이를 콜백으로 사용했다. 예제를 실행해보면 실행 시점으로 1.5초 후에는 ‘obj2’가, 실행 시점으로부터 2초 후에는 ‘obj3’이 출력된다. 이처럼 [예제 4-8]의 방법은 번거롭긴 하지만 this를 우회적으로나마 활용함으로써 다양한 상황에서 원하는 객체를 바라보는 콜백 함수를 만들 수 있는 방법이다.</p>
<p>반면 [예제 4-9]의 경우는 처음부터 바라볼 객체를 명시적으로 obj1로 지정했기 때문에 어떤 방법으로도 다른 객체를 바라보게끔 할 수가 없다. 이런 문제점 때문에 불편할 뿐 아니라 메모리를 낭비하는 측면이 있음에도 [예제 4-8]과 같은 전통적인 방식이 널리 통용될 수밖에 없었던 측면도 있다. 재활용이 필요없는 부분에는 [예제 4-9]와 같이 해도 아무런 문제가 없다. 상황에 따라 적절한 방식을 취해야 한다.</p>
<p>다행히 이제는 전통적인 방식의 아쉬움을 보완하는 훌륭한 방법이 있다. 바로 ES5에서 등장한 bind 메서드를 이용하는 방법이다.</p>
<p>[예제 4-11] 콜백 함수 내부의 this에 다른 값을 바인딩하는 방법(2) - bind 메서드 활용</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">"obj1"</span>,</span><br><span class="line">  func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">setTimeout(obj1.func.bind(obj1), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">"obj2"</span> &#125;;</span><br><span class="line">setTimeout(obj1.func.bind(obj2), <span class="number">1500</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-콜백-지옥과-비동기-제어"><a href="#5-콜백-지옥과-비동기-제어" class="headerlink" title="5. 콜백 지옥과 비동기 제어"></a>5. 콜백 지옥과 비동기 제어</h3><p>콜백 지옥은 콜백 함수를 익명 함수로 전달하는 과정이 반복되어 코드의 들여쓰기 수준이 감당하기 힘들 정도로 깊어지는 현상으로, 자바스크립트에서 흔히 발생하는 문제이다. 주로 이벤트 처리나 서버 통신과 같이 비동기적인 작업을 수행하기 위해 이런 형태가 자주 등장하곤 하는데, 가독성이 떨어질뿐더러 코드를 수정하기도 어렵다.</p>
<p>비동기는 동기의 반대말이다. 동기적인 코드는 현재 실행 중인 코드가 완료된 후에야 다음 코드를 실행하는 방식이다. 반대로 비동기적인 코드는 현재 실행 중인 코드의 완료 여부와 무관하게 즉시 다음 코드로 넘어간다. CPU의 계산에 의해 즉시 처리가 가능한 대부분의 코드는 동기적인 코드이다. 계산식이 복잡해서 CPU가 계산하는 데 시간이 많이 필요한 경우라 하더라도 이는 동기적인 코드이다. 반면 사용자의 요청에 의해 특정 시간이 경과되기 전까지 어떤 함수의 실행을 보류한다거나(setTimeout), 사용자의 직접적인 개입이 있을 때 비로소 어떤 함수를 실행하도록 대기한다거나(addEventListener), 웹브라우저 자체가 아닌 별도의 대상에 무언가를 요청하고 그에 대한 응답이 왔을 때 비로소 어떤 함수를 실행하도록 대기하는 등(XMLHttpRequest), 별도의 요청, 실행 대기, 보류 등과 관련된 코드는 비동기적인 코드이다.</p>
<p>그런데 현대의 자바스크립트는 웹의 복잡도가 높아진 만큼 비동기적인 코드의 비중이 예전보다 훨씬 높아진 상황이다. 그와 동시에 콜백 지옥에 빠지기도 훨씬 쉬워진 셈이다.</p>
<p>[예제 4-12] 콜백 지옥 예시 (1-1)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> coffeeList = name;</span><br><span class="line">  <span class="built_in">console</span>.log(coffeeList)</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params">name</span>)) </span>&#123;</span><br><span class="line">    coffeeList += <span class="string">', '</span> + name;</span><br><span class="line">    <span class="built_in">console</span>.log(coffeeList)</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params">name</span>)) </span>&#123;</span><br><span class="line">      coffeeList += <span class="string">', '</span> + name;</span><br><span class="line">      <span class="built_in">console</span>.log(coffeeList)</span><br><span class="line"></span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params">name</span>)) </span>&#123;</span><br><span class="line">        coffeeList += <span class="string">', '</span> + name;</span><br><span class="line">        <span class="built_in">console</span>.log(coffeeList)</span><br><span class="line">      &#125;, <span class="number">500</span>, <span class="string">'카페라떼'</span>)</span><br><span class="line">    &#125;, <span class="number">500</span>, <span class="string">'카페모카'</span>)</span><br><span class="line">  &#125;, <span class="number">500</span>, <span class="string">'아메리카노'</span>)</span><br><span class="line">&#125;, <span class="number">500</span>, <span class="string">'에스프레소'</span>)</span><br></pre></td></tr></table></figure>

<p>[예제 4-12]는 0.5초 주기마다 커피 목록을 수집하고 출력한다. 각 콜백은 커피 이름을 전달하고 목록에 이름을 추가한다. 목적 달성에는 지장이 없지만 들여쓰기 수준이 과도하게 깊어졌을뿐더러 값이 전달되는 순서가 ‘아래에서 위로’ 향하고 있어 어색하게 느껴질 것이다.</p>
<p>가독성 문제와 어색함을 동시에 해결하는 가장 간단한(?) 방법은 익명의 콜백 함수를 모두 기명함수로 전환하는 것이다.</p>
<p>[예제 4-13] 콜백 지옥 해결 - 기명함수로 변환</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> coffeeList = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> addEspresso = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  coffeeList = name;</span><br><span class="line">  <span class="built_in">console</span>.log(coffeeList);</span><br><span class="line">  setTimeout(addAmericano, <span class="number">500</span>, <span class="string">"아메리카노"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> addAmericano = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  coffeeList += <span class="string">", "</span> + name;</span><br><span class="line">  <span class="built_in">console</span>.log(coffeeList);</span><br><span class="line">  setTimeout(addMocha, <span class="number">500</span>, <span class="string">"카페모카"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> addMocha = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  coffeeList += <span class="string">", "</span> + name;</span><br><span class="line">  <span class="built_in">console</span>.log(coffeeList);</span><br><span class="line">  setTimeout(addLatte, <span class="number">500</span>, <span class="string">"카페라떼"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> addLatte = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  coffeeList += <span class="string">", "</span> + name;</span><br><span class="line">  <span class="built_in">console</span>.log(coffeeList);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">setTimeout(addEspresso, <span class="number">500</span>, <span class="string">"에스프레소"</span>);</span><br></pre></td></tr></table></figure>

<p>이 방식은 코드의 가독성을 높일뿐 아니라 함수 선언과 함수 호출만 구분할 수 있다면 위에서부터 아래로 순서대로 읽어내려가는 데 어려움이 없다. 또한 변수를 최상단으로 끌어올림으로써 외부에 노출되게 됐지만 전체를 즉시 실행 함수 등으로 감싸면 간단히 해결될 문제이다.</p>
<p>지난 십수 년간 자바스크립트는 비동기적인 일련의 작업을 동기적으로, 혹은 동기적인 것처럼 보이게끔 처리해주는 장치를 마련하고자 끊임없이 노력했다. ES6에서는 Promise, Generator 등이 도입됐고, ES2017에서는 async/await가 도입됐다. 이들을 이용해 위 코드를 수정한 내용을 각각 간략하게 소개한다.</p>
<p>[예제 4-14] 비동기 작업의 동기적 표현(1) - Promise(1)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"에스프레소"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">    resolve(name);</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">prevName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> name = prevName + <span class="string">", 아메리카노"</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(name);</span><br><span class="line">        resolve(name);</span><br><span class="line">      &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">prevName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> name = prevName + <span class="string">", 카페모카"</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(name);</span><br><span class="line">        resolve(name);</span><br><span class="line">      &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">prevName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> name = prevName + <span class="string">", 카페라떼"</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(name);</span><br><span class="line">        resolve(name);</span><br><span class="line">      &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>첫 번째로 ES6의 Promise를 이용한 방식이다. new 연산자와 함께 호출한 Promise의 인자로 넘겨주는 콜백 함수는 호출할 때 바로 실행되지만 그 내부에 resolve 또는 reject 함수를 호출하는 구문이 있을 경우 둘 중 하나가 실행되기 전까지는 다음(then) 또는 오류 구문(catch)으로 넘어가지 않는다. 따라서 비동기 작업이 완료될 때 비로소 resolve 또는 reject를 호출하는 방법으로 비동기 작업의 동기적 표현이 가능하다.</p>
<p>[예제 4-15] 비동기 작업의 동기적 표현(2) - Promise(2)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addCoffee = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">prevName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> newName = prevName ? prevName + <span class="string">", "</span> + name : name;</span><br><span class="line">        <span class="built_in">console</span>.log(newName);</span><br><span class="line">        resolve(newName);</span><br><span class="line">      &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">addCoffee(<span class="string">"에스프레소"</span>)()</span><br><span class="line">  .then(addCoffee(<span class="string">"아메리카노"</span>))</span><br><span class="line">  .then(addCoffee(<span class="string">"카페모카"</span>))</span><br><span class="line">  .then(addCoffee(<span class="string">"카페라떼"</span>));</span><br></pre></td></tr></table></figure>

<p>[예제 4-15]는 [예제 4-14]의 반복적인 내용을 함수화해서 더욱 짧게 표현한 것이다.</p>
<p>[예제 4-16] 비동기 작업의 동기적 표현(3) - Generator</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addCoffee = <span class="function"><span class="keyword">function</span>(<span class="params">prevName, name</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    coffeeMaker.next(prevName ? prevName + <span class="string">", "</span> + name : name);</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> coffeeGenerator = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> espresso = <span class="keyword">yield</span> addCoffee(<span class="string">""</span>, <span class="string">"에스프레소"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(espresso);</span><br><span class="line">  <span class="keyword">var</span> americano = <span class="keyword">yield</span> addCoffee(espresso, <span class="string">"아메리카노"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(americano);</span><br><span class="line">  <span class="keyword">var</span> mocha = <span class="keyword">yield</span> addCoffee(americano, <span class="string">"카페모카"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(mocha);</span><br><span class="line">  <span class="keyword">var</span> latte = <span class="keyword">yield</span> addCoffee(mocha, <span class="string">"카페라떼"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(latte);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> coffeeMaker = coffeeGenerator();</span><br><span class="line">coffeeMaker.next();</span><br></pre></td></tr></table></figure>

<p>[예제 4-16]은 ES6의 Generator를 이용했다. 6번째 줄의 <code>*</code>이 붙은 함수가 바로 Generator 함수이다. Generator 함수를 실행하면 Iterator가 반환되는데, Iterator는 next라는 메서드를 가지고 있다. 이 next 메서드를 호출하면 Generator 함수 내부에서 가장 먼저 등장하는 yield에서 함수의 실행을 멈춘다. 이후 다시 next 메서드를 호출하면 앞서 멈췄던 부분부터 시작해서 그다음에 등장하는 yield에서 함수의 실행을 멈춘다. 그러니까 비동기 작업이 완료되는 시점마다 next 메서드를 호출해준다면 Generator 함수 내부의 소스가 위에서부터 아래로 순차적으로 진행된다.</p>
<p>[예제 4-17] 비동기 작업의 동기적 표현(4) - Promise + Async/await</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addCoffee = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(name);</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> coffeeMaker = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> coffeeList = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">var</span> _addCoffee = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    coffeeList += (coffeeList ? <span class="string">","</span> : <span class="string">""</span>) + (<span class="keyword">await</span> addCoffee(name));</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">await</span> _addCoffee(<span class="string">"에스프레소"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(coffeeList);</span><br><span class="line">  <span class="keyword">await</span> _addCoffee(<span class="string">"아메리카노"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(coffeeList);</span><br><span class="line">  <span class="keyword">await</span> _addCoffee(<span class="string">"카페모카"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(coffeeList);</span><br><span class="line">  <span class="keyword">await</span> _addCoffee(<span class="string">"카페라떼"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(coffeeList);</span><br><span class="line">&#125;;</span><br><span class="line">coffeeMaker();</span><br></pre></td></tr></table></figure>

<p>한편 ES2017에서는 가독성이 뛰어나면서도 작성법도 간단한 새로운 기능이 추가됐는데, 바로 async/await 이다. 비동기 작업을 수행하고자 하는 함수 앞에 async를 표기하고, 함수 내부에서 실질적인 비동기 작업이 필요한 위치마다 await를 표기하는 것만으로로 뒤의 내용을 Promise로 자동 전환하고, 해당 내용이 resolve된 이후에야 다음으로 진행된다. 즉 Promise의 then과 흡사한 효과를 얻을 수 있다.</p>
<hr>
<h3 id="6-정리"><a href="#6-정리" class="headerlink" title="6. 정리"></a>6. 정리</h3><ul>
<li>콜백 함수는 다른 코드에 인자로 넘겨줌으로써 그 제어권도 함께 위임한 함수이다</li>
<li>제어권을 넘겨받은 코드는 다음과 같은 제어권을 가진다.</li>
</ul>
<ol>
<li>콜백 함수를 호출하는 시점을 스스로 판단해서 실행한다.</li>
<li>콜백 함수를 호출할 때 인자로 넘겨줄 값들 및 그 순서가 정해져 있다. 이 순서를 따르지 않고 코드를 작성하면 엉뚱한 결과를 얻게 된다.</li>
<li>콜백 함수의 this가 무엇을 바라보도록 할지가 정해져 있는 경우도 있다. 정하지 않은 경우에는 전역객체를 바라본다. 사용자 임의로 this를 바꾸고 싶을 경우 bind 메서드를 활용하면 된다.</li>
</ol>
<ul>
<li>어떤 함수에 인자로 메서드를 전달하더라도 이는 결국 함수로서 실행된다.</li>
<li>비동기 제어를 위해 콜백 함수를 사용하다 보면 콜백 지옥에 빠지기 쉽다. 최근의 ECMAScript에는 Promise, Generator, async/await 등 콜백 지옥에서 벗어날 수 있는 훌륭한 방법들이 속속 등장하고 있다.</li>
</ul>
<p>출처 : <a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId>=206513031" target="_blank" rel="noopener">코어 자바스크립트</a></p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">태그</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/Javascript/">Javascript</a> <a class="tag tag--primary tag--small t-link" href="/tags/콜백-함수/">콜백 함수</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/03/15/Javascript-클로저/"
                    data-tooltip="[Javascript] 클로저"
                    aria-label="이전: [Javascript] 클로저"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/03/01/Javascript-this-2/"
                    data-tooltip="[Javascript] this (2)"
                    aria-label="다음: [Javascript] this (2)"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cok2exe.github.io/2020/03/08/Javascript-콜백-함수/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cok2exe.github.io/2020/03/08/Javascript-콜백-함수/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://cok2exe.github.io/2020/03/08/Javascript-콜백-함수/"
                    title="Google+에 공유하기"
                    aria-label="Google+에 공유하기"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 dajyu. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/03/15/Javascript-클로저/"
                    data-tooltip="[Javascript] 클로저"
                    aria-label="이전: [Javascript] 클로저"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/03/01/Javascript-this-2/"
                    data-tooltip="[Javascript] this (2)"
                    aria-label="다음: [Javascript] this (2)"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cok2exe.github.io/2020/03/08/Javascript-콜백-함수/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cok2exe.github.io/2020/03/08/Javascript-콜백-함수/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://cok2exe.github.io/2020/03/08/Javascript-콜백-함수/"
                    title="Google+에 공유하기"
                    aria-label="Google+에 공유하기"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://cok2exe.github.io/2020/03/08/Javascript-콜백-함수/"
                        aria-label="Facebook에 공유하기"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Facebook에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://cok2exe.github.io/2020/03/08/Javascript-콜백-함수/"
                        aria-label="Twitter에 공유하기"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Twitter에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=https://cok2exe.github.io/2020/03/08/Javascript-콜백-함수/"
                        aria-label="Google+에 공유하기"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Google+에 공유하기</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/over.jpg" alt="저자 이미지"/>
        
            <h4 id="about-card-name">dajyu</h4>
        
            <div id="about-card-bio"><p>혼잣말 공부러(코드사냥꾼)</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Web frontend</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Asia/Seoul
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->


    




    </body>
</html>
